'FTP Client
'Copyright Matt Kilgore -- 2011/2013

'This program is free software, without any warranty of any kind.
'You are free to edit, copy, modify, and redistribute it under the terms
'of the Do What You Want Public License, Version 1, as published by Matt Kilgore
'See file COPYING that should have been included with this source.

SUB GUI_init()
a$ = "QWERTYUIOP????ASDFGHJKL?????ZXCVBNM" 'Credit to Galleon for the ALT key code
FOR x = 1 TO LEN(a$)
  GUI_alt_codes$(x + 15) = MID$(a$, x, 1)
NEXT x
GUI_DEFAULT_COLOR_BOX.mcolor.fr = 7
GUI_DEFAULT_COLOR_BOX.mcolor.bk = 1
GUI_DEFAULT_COLOR_BOX.selcolor.fr = 1
GUI_DEFAULT_COLOR_BOX.selcolor.bk = 7
GUI_DEFAULT_COLOR_BUTTON.mcolor.fr = 7
GUI_DEFAULT_COLOR_BUTTON.mcolor.bk = 1
GUI_DEFAULT_COLOR_BUTTON.selcolor.fr = 15
GUI_DEFAULT_COLOR_BUTTON.selcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.mcolor.fr = 7
GUI_DEFAULT_COLOR_DROP.mcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.selcolor.fr = 15
GUI_DEFAULT_COLOR_DROP.selcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.scroll_color.fr = 0
GUI_DEFAULT_COLOR_DROP.scroll_color.bk = 7
GUI_DEFAULT_COLOR_CHECKBOX.mcolor.fr = 7
GUI_DEFAULT_COLOR_CHECKBOX.mcolor.bk = 1
GUI_DEFAULT_COLOR_CHECKBOX.selcolor.fr = 15
GUI_DEFAULT_COLOR_CHECKBOX.selcolor.bk = 1
GUI_DEFAULT_COLOR_INPUT.mcolor.fr = 7
GUI_DEFAULT_COLOR_INPUT.mcolor.bk = 1
GUI_DEFAULT_COLOR_INPUT.selcolor.fr = 1
GUI_DEFAULT_COLOR_INPUT.selcolor.bk = 7
GUI_DEFAULT_COLOR_LIST.mcolor.fr = 7
GUI_DEFAULT_COLOR_LIST.mcolor.bk = 1
GUI_DEFAULT_COLOR_LIST.selcolor.fr = 15
GUI_DEFAULT_COLOR_LIST.selcolor.bk = 1
GUI_DEFAULT_COLOR_LIST.scroll_color.fr = 0
GUI_DEFAULT_COLOR_LIST.scroll_color.bk = 7
GUI_DEFAULT_COLOR_MENU.mcolor.fr = 0
GUI_DEFAULT_COLOR_MENU.mcolor.bk = 7
GUI_DEFAULT_COLOR_MENU.selcolor.fr = 7
GUI_DEFAULT_COLOR_MENU.selcolor.bk = 0
GUI_DEFAULT_COLOR_MENU.scroll_color.fr = 15
GUI_DEFAULT_COLOR_MENU.scroll_color.bk = 7
GUI_DEFAULT_COLOR_TEXT.mcolor.fr = 7
GUI_DEFAULT_COLOR_TEXT.mcolor.bk = 1
GUI_DEFAULT_COLOR_TEXT.selcolor.fr = 7
GUI_DEFAULT_COLOR_TEXT.selcolor.bk = 1
GUI_DEFAULT_COLOR_TEXT.scroll_color.fr = 0
GUI_DEFAULT_COLOR_TEXT.scroll_color.bk = 7
GUI_DEFAULT_COLOR_RADIO.mcolor.fr = 7
GUI_DEFAULT_COLOR_RADIO.mcolor.bk = 1
GUI_DEFAULT_COLOR_RADIO.selcolor.fr = 15
GUI_DEFAULT_COLOR_RADIO.selcolor.bk = 1
GUI_DEFAULT_COLOR_LABEL.mcolor.fr = 7
GUI_DEFAULT_COLOR_LABEL.mcolor.bk = 1

GUI_DEFAULT_DIALOG_COLOR_BOX.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_BOX.mcolor.bk =7
GUI_DEFAULT_DIALOG_COLOR_BOX.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_BOX.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_BUTTON.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_BUTTON.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_BUTTON.selcolor.fr = 15
GUI_DEFAULT_DIALOG_COLOR_BUTTON.selcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_DROP.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_DROP.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_DROP.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_DROP.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_DROP.scroll_color.fr = 0
GUI_DEFAULT_DIALOG_COLOR_DROP.scroll_color.bk = 7
GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.selcolor.fr = 15
GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.selcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_INPUT.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_INPUT.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_INPUT.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_INPUT.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_LIST.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_LIST.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_LIST.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_LIST.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_LIST.scroll_color.fr = 0
GUI_DEFAULT_DIALOG_COLOR_LIST.scroll_color.bk = 7
GUI_DEFAULT_DIALOG_COLOR_MENU.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_MENU.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_MENU.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_MENU.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_MENU.scroll_color.fr = 15
GUI_DEFAULT_DIALOG_COLOR_MENU.scroll_color.bk = 7
GUI_DEFAULT_DIALOG_COLOR_TEXT.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_TEXT.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_TEXT.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_TEXT.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_TEXT.scroll_color.fr = 0
GUI_DEFAULT_DIALOG_COLOR_TEXT.scroll_color.bk = 7
GUI_DEFAULT_DIALOG_COLOR_RADIO.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_RADIO.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_RADIO.selcolor.fr = 15
GUI_DEFAULT_DIALOG_COLOR_RADIO.selcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_LABEL.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_LABEL.mcolor.bk = 7
END SUB

FUNCTION GUI_update_screen (gui() AS GUI_element_type, gui_num AS INTEGER, sel AS INTEGER)
FOR x = 1 to gui_num
  if gui(x).element_type = GUI_DROP_DOWN and x <> sel and (gui(x).flags AND GUI_FLAG_DROP_FLAG) then
    gui(x).flags = gui(x).flags AND NOT GUI_FLAG_DROP_FLAG
    GUI_update_screen = -1
  end if
  if gui(x).flags AND GUI_FLAG_UPDATED then
    GUI_update_screen = -1
    gui(x).flags = gui(x).flags AND NOT GUI_FLAG_UPDATED
    GUI_debug_output "Element: " + str$(x)
  end if
NEXT x
END FUNCTION

'Inits an element
'While it doesn't do much now besides set some default colors and the name, it's highly likely it may do more in the future
'It should be considered mandintory to use this SUB on all GUI items
'  You should set the element_type before calling this SUB
'  You should also set the GUI_FLAG_DIALOG flag if you intend to use it
SUB GUI_init_element (g as GUI_element_type, nam$)
MEM_put_str g.nam, nam$
SELECT CASE g.element_type
  case GUI_BOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_BOX.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_BOX.selcolor
    else
      g.mcolor = GUI_DEFAULT_COLOR_BOX.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_BOX.selcolor
    end if
  CASE GUI_BUTTON
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_BUTTON.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_BUTTON.selcolor
    else
      g.mcolor = GUI_DEFAULT_COLOR_BUTTON.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_BUTTON.selcolor
    end if
  CASE GUI_DROP_DOWN
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_DROP.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_DROP.selcolor
      g.scroll_color = GUI_DEFAULT_DIALOG_COLOR_DROP.scroll_color
    else
      g.mcolor = GUI_DEFAULT_COLOR_DROP.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_DROP.selcolor
      g.scroll_color = GUI_DEFAULT_COLOR_DROP.scroll_color
    end if
  CASE GUI_CHECKBOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.selcolor
    else
      g.mcolor = GUI_DEFAULT_COLOR_CHECKBOX.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_CHECKBOX.selcolor
    end if
  CASE GUI_INPUT_BOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_INPUT.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_INPUT.selcolor
    else
      g.mcolor = GUI_DEFAULT_COLOR_INPUT.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_INPUT.selcolor
    end if
  CASE GUI_LIST_BOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_LIST.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_LIST.selcolor
      g.scroll_color = GUI_DEFAULT_DIALOG_COLOR_LIST.scroll_color
    else
      g.mcolor = GUI_DEFAULT_COLOR_LIST.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_LIST.selcolor
      g.scroll_color = GUI_DEFAULT_COLOR_LIST.scroll_color
    end if
  CASE GUI_MENU
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_MENU.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_MENU.selcolor
      g.scroll_color = GUI_DEFAULT_DIALOG_COLOR_MENU.scroll_color
    else
      g.mcolor = GUI_DEFAULT_COLOR_MENU.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_MENU.selcolor
      g.scroll_color = GUI_DEFAULT_COLOR_MENU.scroll_color
    end if
    g.flags = g.flags OR GUI_FLAG_SKIP
  CASE GUI_TEXT_BOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_TEXT.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_TEXT.selcolor
      g.scroll_color = GUI_DEFAULT_DIALOG_COLOR_TEXT.scroll_color
    else
      g.mcolor = GUI_DEFAULT_COLOR_TEXT.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_TEXT.selcolor
      g.scroll_color = GUI_DEFAULT_COLOR_TEXT.scroll_color
    end if
  CASE GUI_RADIO_BUTTON
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_RADIO.mcolor
      g.selcolor = GUI_DEFAULT_DIALOG_COLOR_RADIO.selcolor
    else
      g.mcolor = GUI_DEFAULT_COLOR_RADIO.mcolor
      g.selcolor = GUI_DEFAULT_COLOR_RADIO.selcolor
    end if
  CASE GUI_LABEL
    if g.flags AND GUI_FLAG_DIALOG then
      g.mcolor = GUI_DEFAULT_DIALOG_COLOR_LABEL.mcolor
    else
      g.mcolor = GUI_DEFAULT_COLOR_LABEL.mcolor
    end if
    g.flags = g.flags OR GUI_FLAG_SKIP
END SELECT
g.flags = g.flags OR GUI_FLAG_UPDATED
END SUB

FUNCTION GUI_get_layer (b as GUI_element_type)
IF b.element_type <> GUI_DROP_DOWN AND b.element_type <> GUI_MENU then
  GUI_get_layer = b.layer
ELSEIF b.element_type = GUI_DROP_DOWN AND (b.flags AND GUI_FLAG_DROP_FLAG) then
  GUI_get_layer = 128
ELSEIF b.element_type = GUI_DROP_DOWN and not (b.flags AND GUI_FLAG_DROP_FLAG) THEN
  GUI_get_layer = b.layer
ELSEIF b.element_type = GUI_MENU then
  if b.flags AND GUI_FLAG_MENU_OPEN then
    GUI_get_layer = 128
  end if
END IF
END FUNCTION

'Output's debug info to the CONSOLE.
'It's controlable via the GUI_DEBUG const in gui_lib.bi
SUB GUI_debug_output (s$)
IF GUI_DEBUG then
  d& = _DEST
  _DEST _CONSOLE
  PRINT s$
  _DEST d&
end if
END SUB

'###############################################################################
'###############################################################################
'#---------------------------DRAWING FUNCTIONS---------------------------------#
'###############################################################################
'###############################################################################

'Draws an array of elements0, does the following things:
'  respects layering
'  Call's _DISPLAY at start and _AUTODISPLAY at the end
'  Locates the cursor to a proper spot (And stores the location)
SUB GUI_draw_element_array (b() as GUI_element_type, gui_num, selected_gui)
GUI_debug_output "Screen Update."
_DISPLAY
drawn_count = 0
FOR cur_layer = -128 to 128
  for x = 1 to gui_num
    if GUI_get_layer(b(x)) = cur_layer then
      GUI_draw_element b(x), selected_gui = x
      drawn_count = drawn_count + 1
    end if
    if drawn_count = gui_num then exit FOR
  next x
  if draw_count = gui_num then exit FOR
next cur_layer
if b(selected_gui).cur_row > 0 then
  locate b(selected_gui).cur_row, b(selected_gui).cur_col, 1
  GUI_cur_row = b(selected_gui).cur_row
  GUI_cur_col = b(selected_gui).cur_col
else
  locate ,,0
  GUI_cur_row = 0
END IF
_AUTODISPLAY
END SUB

'sel indiciates whether that box is a selected GUI element
'also -- as can be seen this is really just a wrapper around the real drawing SUB's
'SUB's are split up to simplify the process
SUB GUI_draw_element (b AS GUI_element_type, sel) 'Draws box b
'Draws a box
IF b.element_type = GUI_BOX THEN 'Plain box
  if b.flags AND GUI_FLAG_HIDE then
    color b.mcolor.fr, b.mcolor.bk
    for x = b.row1 to b.row2
      locate x, b.col1
      print space$(b.col2 - b.col1 + 1);
    next x
  else
    GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
  end if
ELSEIF b.element_type = GUI_INPUT_BOX THEN 'Input box
  GUI_draw_input_box b, sel

ELSEIF b.element_type = GUI_TEXT_BOX THEN 'TextBox -- not done yet
  GUI_draw_text_box b, sel

ELSEIF b.element_type = GUI_LIST_BOX THEN 'list box
  GUI_draw_list_box b, sel

ELSEIF b.element_type = GUI_DROP_DOWN THEN 'Dropdown
  GUI_draw_dropdown b, sel

ELSEIF b.element_type = GUI_CHECKBOX THEN 'Checkbox
  GUI_draw_checkbox b, sel

ELSEIF b.element_type = GUI_MENU THEN 'Menu
  GUI_draw_menu b, sel

ELSEIF b.element_type = GUI_BUTTON THEN 'Button
  GUI_draw_button b, sel

ELSEIF b.element_type = GUI_RADIO_BUTTON THEN 'Radio button
  GUI_draw_radio_button b, sel

ELSEIF b.element_type = GUI_LABEL THEN 'Label
  GUI_draw_label b, sel

END IF
END SUB

SUB GUI_draw_checkbox (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk ELSE COLOR b.mcolor.fr MOD 8, b.mcolor.bk
PRINT "[";
IF b.flags AND GUI_FLAG_CHECKED THEN PRINT chr$(251); ELSE PRINT " ";
PRINT "]";
COLOR b.mcolor.fr, b.mcolor.bk
PRINT MEM_get_str$(b.nam);
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_radio_button (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk ELSE COLOR b.mcolor.fr MOD 8, b.mcolor.bk
PRINT "(";
IF b.flags AND GUI_FLAG_CHECKED THEN PRINT chr$(254); ELSE PRINT " ";
PRINT ")";
COLOR b.mcolor.fr, b.mcolor.bk
PRINT MEM_get_str$(b.nam);
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_button (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk ELSE COLOR b.mcolor.fr MOD 8, b.mcolor.bk
PRINT "<";
'IF sel THEN COLOR b.selcol, b.c2 ELSE COLOR b.c1 MOD 8, b.c2
COLOR b.mcolor.fr, b.mcolor.bk
PRINT MEM_get_str$(b.nam);
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk ELSE COLOR b.mcolor.fr MOD 8, b.mcolor.bk
PRINT ">";
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_input_box (b as GUI_element_type, sel)

GUI_draw_Box b.row1, b.col1, b.row1 + 2, b.col2, b
s$ = mid$(MEM_get_str$(b.text), b.scroll_offset_hors + 1, b.col2 - b.col1 - 1)
IF (b.flags AND GUI_FLAG_HIDE) THEN s$ = STRING$(LEN(s$), "*")
col1 = b.text_sel_col1
col2 = b.text_sel_col2
if col2 < col1 then
  swap col1, col2
end if
if col1 = col2 OR sel = 0 then
  color b.mcolor.fr, b.mcolor.bk
  LOCATE b.row1 + 1, b.col1 + 1
  's$ = MID$(MEM_get_str$(b.text), b.scroll_offset_hors + 1, b.col2 - b.col1 - 1)
  print s$;
else
  locate b.row1 + 1, b.col1 + 1
  if col1 <= b.scroll_offset_hors then
    'Selected text goes off the left of the box
    color b.selcolor.fr, b.selcolor.bk
    print mid$(s$, 1, col2 - b.scroll_offset_hors);
    color b.mcolor.fr, b.mcolor.bk
    print mid$(s$, col2 - b.scroll_offset_hors + 1);
  elseif col1 > b.scroll_offset_hors and col2 < b.scroll_offset_hors + (b.col2 - b.col1) then
    'Selected text is completely on the screen
    color b.mcolor.fr, b.mcolor.bk
    print mid$(s$, 1, col1 - b.scroll_offset_hors);
    color b.selcolor.fr, b.selcolor.bk
    print mid$(s$, col1 - b.scroll_offset_hors + 1, col2 - col1);
    color b.mcolor.fr, b.mcolor.bk
    print mid$(s$, col2 - b.scroll_offset_hors + 1);
  else
    'Selected text goes off the left of the screen
    color b.mcolor.fr, b.mcolor.bk
    print mid$(s$, 1, col1 - b.scroll_offset_hors + 1);
    color b.selcolor.fr, b.selcolor.bk
    print mid$(s$, col1 - b.scroll_offset_hors + 1);
  end if
end if
b.cur_row = b.row1 + 1
b.cur_col = b.col1 + 1 + b.text_position - b.scroll_offset_hors
END SUB

SUB GUI_draw_dropdown (b as GUI_element_type, sel)
_CONTROLCHR OFF
LOCATE b.row1, b.col1
COLOR b.mcolor.fr, b.mcolor.bk
if b.flags AND GUI_FLAG_DROP_FLAG then
  GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
  _CONTROLCHR OFF
end if
IF (b.flags AND GUI_FLAG_DROP_FLAG) = 0 THEN PRINT "[";
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk
locate b.row1, b.col1 + 1
PRINT LEFT$(MEM_get_str_array$(b.lines, b.selected) + SPACE$(b.col2 - b.col1), b.col2 - b.col1 - 2); CHR$(31);
COLOR b.mcolor.fr, b.mcolor.bk
IF (b.flags AND GUI_FLAG_DROP_FLAG) = 0 THEN PRINT "]";
if b.flags AND GUI_FLAG_DROP_FLAG then
  s = GUI_draw_inside_text(b)
end if
_CONTROLCHR ON
if s = 0 then
  b.cur_row = 0
  b.cur_col = 0
else
  b.cur_row = s + b.row1
  b.cur_col = b.col1 + 1
end if
END SUB

SUB GUI_draw_menu (b as GUI_element_type, sel)
DIM men as GUI_menu_item_type
DIM menu_sel, menu_row1, menu_col1

if NOT sel then b.flags = (b.flags AND NOT GUI_FLAG_MENU_OPEN) AND NOT GUI_FLAG_MENU_ALT : b.selected = 0

locate b.row1, b.col1
color b.mcolor.fr, b.mcolor.bk
print space$(b.col2 - b.col1 + 1)
locate b.row1, b.col1
PRINT SPACE$(b.menu_padding);
for x = 1 to b.length
  men = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
  if x = b.length and (b.flags AND GUI_FLAG_MENU_LAST_ON_RIGHT) then
    locate , b.col2 - GUI_menu_len(MEM_get_Str$(men.nam)) - 2
  end if
  if b.selected = x and sel then
    if b.flags AND GUI_FLAG_MENU_OPEN then
      'menu_sel = x
      menu_row1 = CSRLIN + 1
      menu_col1 = POS(0) - 1
      if menu_col1 < 1 then menu_col1 = 1
    end if
    color b.selcolor.fr, b.selcolor.bk
    if (b.flags AND GUI_FLAG_MENU_ALT) = 0 then
      GUI_print_menu_no_hilight MEM_get_str$(men.nam) ', b.mcolor.fr, b.mcolor.bk, b.scroll_color.fr, b.scroll_color.bk
    else
      GUI_print_menu MEM_get_str$(men.nam), b.selcolor.fr, b.selcolor.bk, b.scroll_color.fr, b.selcolor.bk
    end if
  else
    color b.mcolor.fr, b.mcolor.bk
    if (b.flags AND GUI_FLAG_MENU_ALT) = 0 then
      GUI_print_menu_no_hilight MEM_get_str$(men.nam)
    else
      GUI_print_menu MEM_get_str$(men.nam), b.mcolor.fr, b.mcolor.bk, b.scroll_color.fr, b.mcolor.bk
    end if
  end if
next x
if b.flags AND GUI_FLAG_MENU_OPEN then
  'men = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (b.selected - 1), GUI_menu_item_type)
  GUI_draw_gui_menu b ', men, menu_row1, menu_col1
end if
b.cur_row = 0
b.cur_col = 0
END SUB

SUB GUI_draw_list_box (b as GUI_element_type, sel)
GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
s = GUI_draw_inside_text(b)
if s > 0 then
  b.cur_row = b.row1 + s
  b.cur_col = b.col1 + 1
else
  b.cur_row = 0
end if
END SUB

SUB GUI_draw_text_box (b as GUI_element_type, sel)
GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
s = GUI_draw_inside_text(b)
if s > 0 then
  b.cur_row = b.row1 + s
  b.cur_col = b.col1 + 1 + b.text_position - b.scroll_offset_hors
  if b.cur_col <= b.col1 or b.cur_col >= b.col2 then
    b.cur_row = 0
  end if
else
  b.cur_row = 0
end if
END SUB

SUB GUI_draw_label (b as GUI_element_type, sel)
COLOR b.mcolor.fr, b.mcolor.bk
LOCATE b.row1, b.col1
print MEM_get_str$(b.text);
END SUB

'It draws an open menu box starting at the location row1, col1
'This will also recurse through the menu object and draw open sub_menus, if any
'Takes:
'  b --> GUI element, it's properties (Such as GUI_fLAG_SHADOW and colors) will be used to draw the menu
'  m --> MENU item type, The menu we draw will be it's sub menu
'  row1, col1 --> Location for the top left corner of the menu
'The location of the top left corner will be adjusted by GUI_get_menu_location as nessisary
'This may happen if the normal row1, col1 would draw the menu off screen
SUB GUI_draw_gui_menu (b as GUI_element_type) ', m as GUI_menu_item_type, row1, col1)
STATIC count, m as GUI_menu_item_type
DIM men as GUI_menu_item_type
DIM men_next_menu as GUI_menu_item_type, sub_menu_row1, sub_menu_col1, sub_menu_open

GUI_debug_output "Finding Menu location..."
GUI_get_menu_location b, count + 1, row1, col1, row2, col2

if count = 0 then m = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (b.selected - 1), GUI_menu_item_type)

GUI_debug_output "Row1:" + str$(row1) + " Col1" + str$(col1) + " Row2:" + str$(row2) + " Col2:" + str$(col2)
wid = col2 - col1 - 3
IF b.flags AND GUI_FLAG_SHADOW THEN
  GUI_draw_box_shadow row1, col1, row2, col2
END IF
_CONTROLCHR OFF
color b.mcolor.fr, b.mcolor.bk
locate row1, col1
PRINT CHR$(218); STRING$(col2 - col1 - 1, 196); CHR$(191);
for x = 1 to m.sub_menu_length
  men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
  locate x + row1, col1
  color b.mcolor.fr, b.mcolor.bk
  print chr$(179);
  if MEM_get_str$(men.nam) = "-" then
    if m.selected = x then
      color b.selcolor.fr, b.selcolor.bk
    else
      color b.mcolor.fr, b.mcolor.bk
    end if
    locate , col1
    PRINT CHR$(195); STRING$(col2 - col1 - 1, 196); CHR$(180);
  else
    if m.selected = x then
      if GUI_alt_flag then
        GUI_print_menu MEM_get_str$(men.nam), b.selcolor.fr, b.selcolor.bk, b.scroll_color.fr, b.selcolor.bk
      else
        color b.selcolor.fr, b.selcolor.bk
        GUI_print_menu_no_hilight MEM_get_str$(men.nam)
      end if
    else
      if GUI_alt_flag then
        GUI_print_menu MEM_get_str$(men.nam), b.mcolor.fr, b.mcolor.bk, b.scroll_color.fr, b.mcolor.bk
      else
        GUI_print_menu_no_hilight MEM_get_str$(men.nam)
      end if
    end if
    if men.has_sub then
      PRINT SPACE$(wid - GUI_menu_len(MEM_get_str$(men.nam)) - 1); chr$(16);
    else
      PRINT SPACE$(wid - GUI_menu_len(MEM_get_Str$(men.nam)));
    end if
    if men.sub_menu_open and men.has_sub then
      men_next_menu = men
      sub_menu_row1 = row1 + x - 1
      sub_menu_col1 = col2 + 1
      sub_menu_open = -1
    end if
    color b.mcolor.fr, b.mcolor.bk
    print chr$(179);
  end if
next x
locate row2, col1
color b.mcolor.fr, b.mcolor.bk
print CHR$(192); STRING$(col2 - col1 - 1, 196); CHR$(217);
if sub_menu_open then
  m = men_next_menu
  count = count + 1
  GUI_draw_gui_menu b ', men_next_menu, sub_menu_row1, sub_menu_col1
  count = count - 1
end if
_CONTROLCHR ON
END SUB

'Draws a shadow around the location
'row1, col1, row2, col2 are not the location of the shadow, but the location of the box the shadow will be around
'The settings in this SUB draw the shadow two columns past the box on the left, and one row past the box on the bottom
SUB GUI_draw_box_shadow (row1, col1, row2, col2)
_CONTROLCHR OFF
'FOR x = row1 + 1 TO row2 + 1
'  FOR y = col1 + 2 TO col2 + 2
'    chr = SCREEN(x, y)
'    colo = SCREEN(x, y, 1)
'    LOCATE x, y
'    COLOR colo MOD 8, 0
'    PRINT CHR$(chr);
'  NEXT y
'NEXT x
FOR y = col1 + 2 TO col2 + 2
  chr = SCREEN(row2 + 1, y)
  colo = SCREEN(row2 + 1, y, 1)
  LOCATE row2 + 1, y
  COLOR colo MOD 8, 0
  PRINT CHR$(chr);
NEXT y
FOR x = row1 + 1 to row2 + 1
  FOR y = col2 + 1 to col2 + 2
    chr = SCREEN(x, y)
    colo = SCREEN(x, y, 1)
    LOCATE x, y
    color colo MOD 8, 0
    PRINT chr$(chr);
  next y
NEXT x
_CONTROLCHR ON
END SUB

SUB GUI_draw_box (row1, col1, row2, col2, b as GUI_element_type)
IF b.flags AND GUI_FLAG_SHADOW THEN
  GUI_draw_box_shadow row1, col1, row2, col2
END IF
_CONTROLCHR OFF
if (b.flags AND GUI_FLAG_SCROLL_V) and (b.scroll_loc_vert = 0) then GUI_calc_scroll row1, col1, row2, col2, b
if (b.flags AND GUI_FLAG_SCROLL_H) and (b.scroll_loc_hors = 0) then GUI_calc_scroll row1, col1, row2, col2, b
n$ = MEM_get_str$(b.nam)
COLOR b.mcolor.fr, b.mcolor.bk
LOCATE row1, col1
PRINT CHR$(218); CHR$(196); n$; STRING$(col2 - col1 - 2 - LEN(n$), 196); CHR$(191);
FOR x = row1 + 1 TO row2 - 1
  LOCATE x, col1
  COLOR b.mcolor.fr, b.mcolor.bk
  PRINT CHR$(179); SPACE$(col2 - col1 - 1);
  IF (b.flags AND GUI_FLAG_SCROLL_V) = 0 THEN
    PRINT CHR$(179);
  END IF
  IF b.flags AND GUI_FLAG_SCROLL_V THEN
    COLOR b.scroll_color.fr, b.scroll_color.bk
    SELECT CASE x
      CASE row1 + 1
        PRINT CHR$(24);
      CASE row2 - 1
        PRINT CHR$(25);
      CASE ELSE
        IF b.scroll_loc_vert = x THEN
          PRINT CHR$(219);
        ELSE
          PRINT CHR$(176);
        END IF
    END SELECT
  END IF
NEXT x
COLOR b.mcolor.fr MOD 8, b.mcolor.bk
LOCATE row2, col1
print CHR$(192);
if NOT (b.flags AND GUI_FLAG_SCROLL_H) then
  PRINT STRING$(col2 - col1 - 1, 196);
else
  color b.scroll_color.fr, b.scroll_color.bk
  PRINT chr$(27);
  print string$(b.scroll_loc_hors - b.col1 - 2, 176);
  print chr$(219);
  print string$(b.col2 - b.scroll_loc_hors - 2, 176); chr$(26);
  COLOR b.mcolor.fr MOD 8, b.mcolor.bk
end if
print CHR$(217);
_CONTROLCHR ON
END SUB

FUNCTION GUI_draw_inside_text (b as GUI_element_type)
for x = 1 to b.row2 - b.row1 - 1
  locate x + b.row1, b.col1 + 1
  if (b.selected - b.scroll_offset_vert) = (x) then
    s = x
    color b.selcolor.fr, b.selcolor.bk
  else
    color b.mcolor.fr, b.mcolor.bk
  end if
  if x + b.scroll_offset_vert <= b.length then
    k$ = mid$(MEM_get_str_array$(b.lines, x + b.scroll_offset_vert), b.scroll_offset_hors + 1, b.col2 - b.col1 - 1)
  else
    k$ = ""
  end if
  k$ = k$ + space$((b.col2 - b.col1 - 1) - len(k$))
  print k$;
next x
GUI_draw_inside_text = s
END FUNCTION


SUB GUI_print_menu_no_hilight (a$) 'Prints a$ without the '#' and no hilighting
PRINT " "; MID$(a$, 1, INSTR(a$, "#") - 1); MID$(a$, INSTR(a$, "#") + 1); " ";
END SUB

SUB GUI_print_menu (a$, c1, c2, menu_c1, menu_c2) 'Prints a$ with the character after '#' hilighted in bright white
color c1, c2
PRINT " "; MID$(a$, 1, INSTR(a$, "#") - 1);
COLOR menu_c1, menu_c2
PRINT MID$(a$, INSTR(a$, "#") + 1, 1);
COLOR c1, c2
PRINT MID$(a$, INSTR(a$, "#") + 2); " ";
END SUB

'###############################################################################
'###############################################################################
'#-----------------------MEMORY FREEING FUNCTIONS------------------------------#
'###############################################################################
'###############################################################################


'Recurses through a menu element to free all it's assosiated sub menus before freeing the actual menu
SUB GUI_free_menu(m as GUI_menu_item_type)
DIM men as GUI_menu_item_type
MEM_free_string m.nam 'First free it's strings
MEM_free_string m.key_combo
if m.has_sub then
  FOR x = 1 to m.sub_menu_length 'free any sub menus of this item
    men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
    GUI_free_menu men
  next x
  _MEMFREE m.sub_menu
end if
'... I don't think I need to free the _MEM (m.sub_menu) because it points to a fixed array
' EDIT I was wrong... I think...
END SUB

'Call to free the memory of an array of GUI elements
SUB GUI_free_element_array (b() as GUI_element_type)
for x = 1 to ubound(b)
  GUI_free_element b(x)
next x
END SUB

'Call to free the memory being used by a GUI element
SUB GUI_free_element (b as GUI_element_type)
DIM m as GUI_menu_item_type
MEM_free_string b.nam 'Free MEM_string_type's and MEM_array_Types
MEM_free_string b.text
MEM_free_array b.lines
IF b.element_type = GUI_MENU then 'If we're a menu, then we have to free our menu items
  if b.length > 0 then
    FOR x = 1 to b.length
      m = _MEMGET(b.menu, b.menu.OFFSET + len(m) * (x - 1), GUI_menu_item_type)
      GUI_free_menu m
    next x
  end if
  _MEMFREE b.menu
end if
END SUB

'###############################################################################
'###############################################################################
'#------------------------------MENU FUNCTIONS---------------------------------#
'###############################################################################
'###############################################################################

'Attaches a sub menu to a menu item
'Takes:
'  menu_item --> The menu item you want to attach a sub-menu too
'  item_num --> Number of choices in the sub menu
'  items --> _OFFSET to an array of GUI_menu_item_type, it should be of size item_num
'Call just like GUI_attach_base_menu, except with a GUI_menu_item_type in place of the GUI element
SUB GUI_attach_menu (menu_item as GUI_menu_item_type, item_num AS INTEGER, items as _OFFSET)
menu_item.sub_menu_length = item_num
menu_item.sub_menu = _MEM(items, LEN(menu_item) * item_num)
menu_item.has_sub = -1
menu_item.selected = 0
END SUB

'Attaches the base menu (Horisontal menu) to a GUI_MENU
'Takes:
'  g --> GUI element, the GUI_MENU you want to attach the menu too
'  item_num --> Number of menu items
'  items --> an _OFFSET to an array of GUI_menu_item_type, it should be of size item_num
'If you just use arrays of GUI_menu_item_type then call this using _OFFSET(array_name) for the last parameter
SUB GUI_attach_base_menu (g as GUI_element_type, item_num AS INTEGER, items as _OFFSET)
DIM m as GUI_menu_item_type
g.menu = _MEM(items, LEN(m) * item_num)
g.length = item_num
END SUB

'Returns the drawn location of a menu taking into account movement so it
'doesn't go off the screen
'Takes:
'  b --> The GUI element for the GUI_MENU
'  m --> The menu you're going to draw
'  row1, col1 --> The wanted location of the menu
'Returns:
'  row1, col1, row2, col2 --> The location the menu will drawn at
'row1 and col1 won't change unless they have to be moved so the menu isn't off screen


SUB GUI_get_menu_location (b as GUI_element_type, sel, row1, col1, row2, col2)
STATIC count, m as GUI_menu_item_type
DIM men as GUI_menu_item_type, mnext as GUI_menu_item_type
GUI_debug_output "R Count:" + str$(count) + "   SEL=" + str$(sel)
if count = 0 then
  row1 = b.row1
  col1 = b.col1
  row2 = b.row1
  col2 = b.col2
else
  if count = 1 then
    row1 = b.row1
    col2 = b.col1 + b.menu_padding - 1
    for x = 1 to b.selected
      men = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
      if x = b.length AND (b.flags AND GUI_FLAG_MENU_LAST_ON_RIGHT) then
        col1 = b.col2 - GUI_menu_len(MEM_get_str$(men.nam)) - 2
      else
        col1 = col2
      end if
      col2 = col1 + 2 + GUI_menu_len(MEM_get_str$(men.nam))
    next x
    row2 = row1
    m = men
  else
    col1 = col2 + 1
  end if

  wid = 0
  if col1 <=0 then
    col1 = 1
  end if
  if row1 <= 0 then
    row1 = 1
  end if
  row1 = row1 + 1
  row2 = row1 + m.sub_menu_length + 1
  GUI_debug_output "Here"
  GUI_debug_output "Mnam: " + MEM_get_str$(m.nam)
  GUI_debug_output "Msub_length: " + str$(m.sub_menu_length)
  GUI_debug_output "Mselected: " + str$(m.selected)
  GUI_debug_output "MOff: " + str$(m.sub_menu.OFFSET)
  for x = 1 to m.sub_menu_length
    GUI_debug_output "Grabbing entry " + str$(x)
    men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
    GUI_debug_output "Name: " + MEM_get_str$(men.nam)
    l = GUI_menu_len(MEM_get_str$(men.nam))
    if l > wid then
      wid = l
    end if
    if men.has_sub then
      has_sub = -1
      if x = m.selected and m.sub_menu_open then mnext = men
    end if
  next x
  GUI_debug_output "Done!"
  if has_sub then wid = wid + 2
  col2 = col1 + wid + 3
  row2 = row1 + m.sub_menu_length + 1
  if b.flags AND GUI_FLAG_SHADOW then c = col2 + 2 else c = col2
  if c  > _WIDTH(0) then
    col1 = col1 - (c - _WIDTH(0))
    col2 = col1 + wid + 3
  end if
  if row2 > _HEIGHT(0) then
    row1 = row1 - m.sub_menu_length - 2
    if b.flags AND GUI_FLAG_SHADOW then row1 = row1 - 1
    row2 = row1 + m.sub_menu_length + 2
  end if
end if
count = count + 1
if count <= sel then
  m = mnext
  GUI_get_menu_location b, sel, row1, col1, row2, col2
end if
count = count - 1
END SUB

FUNCTION GUI_menu_len (a$) 'Length of menu item a$.
'Just takes one away from the length if the string has a '#'`
IF INSTR(a$, "#") THEN
  GUI_menu_len = LEN(a$) - 1
ELSE
  GUI_menu_len = LEN(a$)
END IF
END FUNCTION

FUNCTION GUI_menu_char$ (a$) 'Get's the hilighted character
GUI_menu_char$ = MID$(a$, INSTR(a$, "#") + 1, 1)
END FUNCTION

'Returns the current locate of the open menu, if any
'Sends back -1 if there was an open menu at that debth
'Sends zero if there was no menu open that deep
'FUNCTION GUI_get_menu_location (b as GUI_element_type, debth, row1, col1, row2, col1)

'END FUNCTION

'send it the X and Y of the mouse as well an GUI_MENU element
'If it returned -1 then the debth of the menu it clicked on will be in debth
'And element will be 'selection'
FUNCTION GUI_menu_clicked_on (b as GUI_element_type, cx, cy, debth, selection)
STATIC count, m AS GUI_menu_item_type
DIM men as GUI_menu_item_type, mtmp as GUI_menu_item_type
GUI_debug_output "T Count:" + str$(count)
GUI_get_menu_location b, count, row1, col1, row2, col2
GUI_debug_output "CLICKED Row1:" + str$(row1) + " Col1" + str$(col1) + " Row2:" + str$(row2) + " Col2:" + str$(col2)
GUI_debug_output "MOUSE Row1:" + str$(cy) + " Col1" + str$(cx)
if cx >= col1 and cx <= col2 and cy >= row1 and cy <= row2 then
  GUI_debug_output "Menu was Clicked on!"
  clicked = -1
  debth = count
  selection = 0
  if count = 0 then
    'row1 = b.row1
    'col2 = b.col1 + b.menu_padding
    c = col1 + b.menu_padding
    for x = 1 to b.length
      men = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
      if x = b.length AND (b.flags AND GUI_FLAG_MENU_LAST_ON_RIGHT) then
        c = b.col2 - GUI_menu_len(MEM_get_str$(men.nam)) - 2
      else
        c = c
      end if
      if cx >= c and cx <= c + 2 + GUI_menu_len(MEM_get_str$(men.nam)) then
        selection = x
      end if
      c = c + 2 + GUI_menu_len(MEM_get_str$(men.nam))
    next x
    row2 = row1
  else
    s = cy - row1
    if s > 0 and s <= row2 - row1 then
      mtmp = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(mtmp) * (m.selected - 1), GUI_menu_item_type)
      if MEM_get_str$(mtmp.nam) <> "-" then
        selection = s
      else
        clicked = 0
      end if
    end if
  end if
  'selection =
else
  if count = 0 then
    if b.selected > 0 then
      m = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (b.selected - 1), GUI_menu_item_type)
      h_sub_menu = -1
    end if
  else
    if m.has_sub and m.sub_menu_open then
      GUI_debug_output "Recursing into next SUB menu"
      m = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(m) * (m.selected - 1), GUI_menu_item_type)
      h_sub_menu = -1
    end if
  end if
end if
'if clicked = 0 then
count = count + 1
'd = debth
's = selection

if selection = 0 and h_sub_menu then 
' ----- Check for a sub-menu before recursing -- Don't recurse if there isn't a sub-menu
  clicked = clicked OR GUI_menu_clicked_on(b, cx, cy, debth, selection)
end if

'if tclicked = 0 then
'  d = debth
count = count - 1
'end if
GUI_debug_output "Debth: " + str$(debth) + " Sel: " + str$(selection)
GUI_debug_output "Clicked: " + str$(clicked)
if clicked then GUI_menu_clicked_on = -1
END FUNCTION

'recursivly close sub menus by setting their selected value to zero
SUB GUI_close_sub_menu (m as GUI_menu_item_type)
DIM men as GUI_menu_item_type
if m.has_sub then
  FOR x = 1 to m.sub_menu_length
    men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
    men.sub_menu_open = 0
    _MEMPUT m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), men
  next x
end if
'if m.has_sub then
'  FOR x = 1 to m.sub_menu_length
'    men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET, GUI_menu_item_type)
'    men.selected = 0
'    _MEMPUT m.sub_menu, m.sub_menu.OFFSET, men
'    GUI_close_sub_menu men
'  NEXT X
'end if
END SUB


'###############################################################################
'###############################################################################
'#-----------------------------SCROLL FUNCTIONS--------------------------------#
'###############################################################################
'###############################################################################

SUB GUI_fix_scroll (gui AS GUI_element_type)
if gui.selected - 1 < gui.scroll_offset_vert then
  gui.scroll_offset_vert = gui.selected - 1
elseif gui.selected > gui.scroll_offset_vert + (gui.row2 - gui.row1 - 1) then
  gui.scroll_offset_vert = gui.selected  - (gui.row2 - gui.row1 - 1)
end if
if gui.scroll_offset_vert < 0 then gui.scroll_offset_vert = 0
if gui.scroll_offset_vert + (gui.row2 - gui.row1 - 1) > gui.length then
  gui.scroll_offset_vert = gui.length - (gui.row2 - gui.row1 - 1)
end if
END SUB

'This will recalculate scroll bar locations
SUB GUI_calc_scroll (row1, col1, row2, col2, b as GUI_element_type)
if b.scroll_offset_vert + (row2 - row1 - 1) > b.length and b.length > row2 - row1 - 1 then
  b.scroll_offset_vert = b.length - (row2 - row1 - 1)
elseif b.length < row2 - row1 - 1 then
  b.scroll_offset_vert = 0
end if
IF b.flags AND GUI_FLAG_SCROLL_V THEN
  if (b.length - (row2 - row1 - 1)) > 0 then
    b.scroll_loc_vert = (((b.scroll_offset_vert) / (b.length - (row2 - row1 - 1))) * (row2 - row1 - 4) + row1 + 2)
  else
    b.scroll_loc_vert = row1
  end if
end if
if b.flags AND GUI_FLAG_SCROLL_H then
  if (b.scroll_max_hors - (col2 - col1 - 1)) > 0 then
    b.scroll_loc_hors = (((b.scroll_offset_hors) / (b.scroll_max_hors - (col2 - col1 - 1))) * (col2 - col1 - 4) + col1 + 2)
  else
    b.scroll_loc_hors = col1
  end if
end if
END SUB

SUB GUI_calc_vert_offset (g as GUI_element_type)
l = g.scroll_loc_vert - g.row1 - 2
g.scroll_offset_vert = ( l / (g.row2 - g.row1 - 4)) * (g.length - (g.row2 - g.row1 - 1))
END SUB

SUB GUI_calc_hors_offset (g as GUI_element_type)
l = g.scroll_loc_hors - g.col1 - 2
g.scroll_offset_hors = ( l / (g.col2 - g.col1 - 4)) * (g.scroll_max_hors - (g.col2 - g.col1 - 1))
END SUB

'###############################################################################
'###############################################################################
'#---------------------------TEXT INPUT FUNCTIONS------------------------------#
'###############################################################################
'###############################################################################

'Call to add a string to the GUI element b (Should be a GUI_INPUT_BOX)
SUB GUI_add_character (b AS GUI_element_type, ch$)
t$ = MEM_get_str$(b.text)
col1 = b.text_sel_col1
col2 = b.text_sel_col2
if col1 > col2 then swap col1, col2
if col1 <> col2 then GUI_del_character b

t$ = MID$(t$, 1, b.text_position) + ch$ + MID$(t$, b.text_position + 1)
'print "T="; t$;
'_DISPLAY
'sleep
MEM_put_str b.text, t$
b.text_position = b.text_position + len(ch$)
IF b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 2) THEN
  b.scroll_offset_hors = b.text_position - (b.col2 - b.col1 - 2)
  'do
  '  b.scroll_offset_hors = b.scroll_offset_hors + 1
  'loop until b.text_position <= b.scroll_offset_hors + (b.col2 - b.col1 - 2)
END IF
END SUB

'Call to delete a single character from the GUI element b (Should be a GUI_INPUT_BOX)
SUB GUI_del_character (b AS GUI_element_type)
t$ = MEM_get_str$(b.text)
col1 = b.text_sel_col1
col2 = b.text_sel_col2
if col1 > col2 then swap col1, col2
IF LEN(t$) > 0 AND b.text_position > 0 AND col1 = col2 THEN
  t$ = MID$(t$, 1, b.text_position - 1) + MID$(t$, b.text_position + 1)
  MEM_put_str b.text, t$
  b.text_position = b.text_position - 1
  IF b.text_position < b.scroll_offset_hors THEN
    b.scroll_offset_hors = b.text_position + 1
  END IF
ELSEIF col1 <> col2 then
  t$ = mid$(t$, 1, col1) + mid$(t$, col2 + 1)
  MEM_put_str b.text, t$
  b.text_position = col1
  IF b.text_position < b.scroll_offset_hors THEN
    b.scroll_offset_hors = b.text_position - 1
  END IF
  b.text_sel_col1 = b.text_sel_col2
END IF
END SUB

SUB GUI_add_character_text_box (b AS GUI_element_type, ch$)
t$ = MEM_get_str_array$(b.lines, b.selected)
if len(t$) >= b.text_position then
  t$ = MID$(t$, 1, b.text_position) + ch$ + MID$(t$, b.text_position + 1)
else
  t$ = t$ + space$(b.text_position - len(t$)) + ch$
end if
'print "T="; t$;
'_DISPLAY
'sleep
MEM_put_str_array b.lines, b.selected, t$
b.text_position = b.text_position + 1
IF b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 2) THEN
  b.scroll_offset_hors = b.scroll_offset_hors + 1
END IF
END SUB

SUB GUI_del_character_text_box (b AS GUI_element_type)
t$ = MEM_get_str_array$(b.lines, b.selected)
IF LEN(t$) > 0 AND b.text_position > 0 and len(t$) >= b.text_position THEN
  t$ = MID$(t$, 1, b.text_position - 1) + MID$(t$, b.text_position + 1)
  MEM_put_str_array b.lines, b.selected, t$
  b.text_position = b.text_position - 1
  IF b.text_position < b.scroll_offset_hors THEN
    b.scroll_offset_hors = b.scroll_offset_hors - 1
  END IF
elseif len(t$) < b.text_position then
  do while b.text_position > len(t$)
    b.text_position = b.text_position - 1
    IF b.text_position < b.scroll_offset_hors THEN
      b.scroll_offset_hors = b.scroll_offset_hors - 1
    END IF
  loop
elseif b.text_position = 0 and b.selected > 1 then
  'append text to line above, shift all lines below the selected one up, decrease selected line
  k$ = MEM_get_str_array$(b.lines, b.selected - 1)
  lengt = len(k$)
  MEM_put_str_array b.lines, b.selected - 1, (k$ + t$)
  for x = b.selected to b.length - 1
    MEM_put_str_array b.lines, x, MEM_get_str_array$(b.lines, x + 1)
  next x
  MEM_put_str_array b.lines, b.length, ""
  b.selected = b.selected - 1
  b.length = b.length - 1
  b.text_position = lengt
  if b.selected < b.scroll_offset_vert then
    b.scroll_offset_vert = b.scroll_offset_vert - 1
  end if
  if b.text_position < b.scroll_offset_hors then
    do while b.text_position < b.scroll_offset_hors
      b.text_position = b.text_position + 1
    loop
  elseif b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 1) then
    do while b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 1)
      b.scroll_offset_hors = b.scroll_offset_hors + 1
    loop
  end if
END IF
GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
END SUB

FUNCTION GUI_inkey$ (gui() AS GUI_element_type, gui_num AS INTEGER, sel)
DIM tempm AS GUI_menu_item_type, men AS GUI_menu_item_type

keys = _KEYDOWN(100307) + _KEYDOWN(100308) * 2
IF (keys) AND GUI_alt_flag = 0 THEN 'Alt Hold
  GUI_debug_output "Alt Held"
  GUI_alt_flag = -1
  'Switch to menu item if one is in gui()
  if gui(sel).element_type <> GUI_MENU or (((gui(sel).flags AND GUI_FLAG_MENU_OPEN) OR (gui(sel).flags AND GUI_FLAG_MENU_ALT)) = 0) then
    for x = 1 to gui_num
      if gui(x).element_type = GUI_MENU then
        gui(x).flags = (gui(x).flags OR GUI_FLAG_MENU_ALT OR GUI_FLAG_UPDATED) AND NOT GUI_FLAG_MENU_OPEN
        gui(x).selected_old = sel
        sel = x 'change selected
      end if
    next x
  elseif gui(sel).element_type = GUI_MENU and (gui(sel).flags AND GUI_FLAG_MENU_OPEN) then
    gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
  end if
END IF
IF keys = 0 AND GUI_alt_flag THEN 'Alt Release
  GUI_debug_output "Alt Release"
  GUI_alt_flag = 0
  if gui(sel).flags AND GUI_FLAG_MENU_ALT then
    gui(sel).flags = gui(sel).flags AND NOT GUI_FLAG_MENU_ALT
    if gui(sel).selected > 0 then
      men = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), GUI_menu_item_type)
      men.selected = 1
      _MEMPUT gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), men
    elseif gui(sel).selected = 0 then
      sel = gui(sel).selected_old
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  elseif gui(sel).flags AND GUI_FLAG_MENU_OPEN then
    gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
  end if
END IF
keys = _KEYDOWN(100305) + _KEYDOWN(100306) * 2
if keys AND GUI_ctl_flag = 0 THEN 'Ctl hold
  GUI_debug_output "Ctl Held"
  GUI_ctl_flag = -1
elseif keys = 0 AND GUI_ctl_flag then 'Ctl Release
  GUI_debug_output "Ctl Release"
  GUI_ctl_flag = 0
end if

GUI_shift_flag = _KEYDOWN(100303) + _KEYDOWN(100304) * 2

ch$ = INKEY$

if ch$ > "" then
  if len(ch$) >= 2 then
    GUI_debug_output "INKEY$:" + str$(ASC(ch$, 1)) + str$(ASC(ch$, 2))
  else
    GUI_debug_output "INKEY$:" + str$(ASC(ch$, 1))
  end if
end if

SELECT CASE ch$
  CASE " " TO "~" 'typeable character
    if gui(sel).element_type = GUI_INPUT_BOX then
      GUI_add_character gui(sel), ch$
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    ELSEIF gui(sel).element_type = GUI_TEXT_BOX then
      GUI_add_character_text_box gui(sel), ch$
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    elseif ch$ = " " and gui(sel).element_type = GUI_CHECKBOX then
      gui(sel).flags = (gui(sel).flags XOR GUI_FLAG_CHECKED) OR GUI_FLAG_UPDATED
    elseif ch$ = " " and gui(sel).element_type = GUI_RADIO_BUTTON then
      gui(sel).flags = (gui(sel).flags OR GUI_FLAG_CHECKED) OR GUI_FLAG_UPDATED
      FOR x = 1 to gui_num
        if x <> sel then
          if gui(x).element_type = GUI_RADIO_BUTTON then
            if gui(x).group = gui(sel).group then
              gui(x).flags = gui(x).flags AND NOT GUI_FLAG_CHECKED
            end if
          end if
        end if
      NEXT x
    elseif ch$ = " " and gui(sel).element_type = GUI_BUTTON then
      GUI_queue_mouse_click sel
    end if
  CASE CHR$(8) 'BACKSPACE
    if gui(sel).element_type = GUI_INPUT_BOX then
      GUI_del_character gui(sel)
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    elseif gui(sel).element_type = GUI_TEXT_BOX then
      GUI_del_character_text_box gui(sel)
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  CASE chr$(9) 'Tab
    do
      sel = (sel mod gui_num) + 1
    loop until (gui(sel).flags AND GUI_FLAG_SKIP) = 0
    gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
  CASE CHR$(13) 'Enter
    if gui(sel).element_type = GUI_TEXT_BOX then
      tex$ = mid$(MEM_get_str_array$(gui(sel).lines, gui(sel).selected), gui(sel).text_position + 1)

      if gui(sel).length + 1 > gui(sel).lines.allocated and (gui(sel).length < gui(sel).max_lines OR gui(sel).max_lines = 0) then
        MEM_allocate_string_array gui(sel).lines, gui(sel).length + 10
        gui(sel).length = gui(sel).length + 1
      elseif gui(sel).length < gui(sel).max_lines OR gui(sel).max_lines = 0 then
        gui(sel).length = gui(sel).length + 1
      end if

      for x = gui(sel).length to gui(sel).selected + 1 STEP -1
        MEM_put_str_array gui(sel).lines, x, MEM_get_str_array$(gui(sel).lines, x - 1)
      next x

      MEM_put_str_array gui(sel).lines, gui(sel).selected + 1, tex$
      MEM_put_str_array gui(sel).lines, gui(sel).selected, mid$(MEM_get_str_array$(gui(sel).lines, gui(sel).selected), 1, gui(sel).text_position)
      gui(sel).selected = gui(sel).selected + 1
      if gui(sel).selected > gui(sel).length then
        gui(sel).selected = gui(sel).selected - 1
      end if
      gui(sel).text_position = 0
      gui(sel).scroll_offset_hors = 0
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      if gui(sel).selected > gui(sel).scroll_offset_vert + (gui(sel).row2 - gui(sel).row1 - 1) then
        gui(sel).scroll_offset_vert = gui(sel).scroll_offset_vert + 1
      end if

      GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
    elseif gui(sel).element_type = GUI_MENU and gui(sel).selected > 0 then
      if ((gui(sel).flags AND GUI_FLAG_MENU_ALT) OR (gui(sel).flags AND GUI_FLAG_MENU_OPEN)) = 0 then
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_MENU_OPEN
        tempm = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(tempm) * (gui(sel).selected - 1), GUI_menu_item_type)
        GUI_close_sub_menu tempm
      elseif gui(sel).flags AND GUI_FLAG_MENU_OPEN then
        tempm = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(tempm) * (gui(sel).selected - 1), GUI_menu_item_type)
        men = _MEMGET(tempm.sub_menu, tempm.sub_menu.OFFSET + len(tempm) * (tempm.selected - 1), GUI_menu_item_type)
        if NOT men.has_sub then
          gui(sel).menu_choice = men.ident
          gui(sel).selected = 0
          gui(sel).flags = (gui(sel).flags OR GUI_FLAG_MENU_CHOSEN OR GUI_FLAG_UPDATED) AND NOT GUI_FLAG_MENU_OPEN
        else
          men.selected = 1
          gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
        end if
      end if
    elseif gui(sel).element_type = GUI_BUTTON then
      GUI_queue_mouse_click sel
    elseif gui(sel).element_type = GUI_RADIO_BUTTON then
      gui(sel).flags = gui(sel).flags XOR GUI_FLAG_CHECKED
      FOR x = 1 to gui_num
        if x <> sel then
          if gui(x).element_type = GUI_RADIO_BUTTON then
            if gui(x).group = gui(sel).group then
              gui(x).flags = gui(sel).flags AND NOT GUI_FLAG_CHECKED
            end if
          end if
        end if
      NEXT x
    elseif gui(sel).element_type = GUI_CHECKBOX then
      gui(sel).flags = gui(sel).flags XOR GUI_FLAG_CHECKED
    elseif gui(sel).element_type = GUI_DROP_DOWN then
      gui(sel).flags = (gui(sel).flags XOR GUI_FLAG_DROP_FLAG) OR GUI_FLAG_UPDATED
    elseif gui(sel).element_type = GUI_LIST_BOX then
      GUI_queue_mouse_click sel
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  CASE CHR$(0) + CHR$(80) 'DOWN
    if gui(sel).element_type = GUI_LIST_BOX OR gui(sel).element_type = GUI_TEXT_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND (gui(sel).flags AND GUI_FLAG_DROP_FLAG)) then
      if gui(sel).selected < gui(sel).length then
        gui(sel).selected = gui(sel).selected + 1
        GUI_fix_scroll gui(sel)
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      end if
    ELSEIF gui(sel).element_type = GUI_DROP_DOWN then
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_DROP_FLAG
    ELSEIF gui(sel).element_type = GUI_MENU and gui(sel).selected > 0  then
      if ((gui(sel).flags AND GUI_FLAG_MENU_ALT) OR (gui(sel).flags AND GUI_FLAG_MENU_OPEN)) = 0 then
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_MENU_OPEN
      elseif gui(sel).flags AND GUI_FLAG_MENU_OPEN then
        tempm = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(tempm) * (gui(sel).selected - 1), GUI_menu_item_type)
        do
          tempm.selected = (tempm.selected mod tempm.sub_menu_length) + 1
          men = _MEMGET(tempm.sub_menu, tempm.sub_menu.OFFSET + len(tempm) * (tempm.selected - 1), GUI_menu_item_type)
        loop until MEM_get_str$(men.nam) <> "-"
        _MEMPUT gui(sel).menu, gui(sel).menu.OFFSET + len(tempm) * (gui(sel).selected - 1), tempm
      end if
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  CASE CHR$(0) + CHR$(72) 'UP
    if gui(sel).element_type = GUI_LIST_BOX OR gui(sel).element_type = GUI_TEXT_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND (gui(sel).flags AND GUI_FLAG_DROP_FLAG))  then
      if gui(sel).selected > 1 then
        gui(sel).selected = gui(sel).selected - 1
        GUI_fix_scroll gui(sel)
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      end if
    elseif gui(sel).element_type = GUI_MENU then
      if gui(sel).flags AND GUI_FLAG_MENU_OPEN then
        tempm = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(tempm) * (gui(sel).selected - 1), GUI_menu_item_type)
        do
          tempm.selected = tempm.selected - 1
          if tempm.selected = 0 then
            tempm.selected = tempm.sub_menu_length
          end if
          men = _MEMGET(tempm.sub_menu, tempm.sub_menu.OFFSET + len(tempm) * (tempm.selected - 1), GUI_menu_item_type)
        loop until MEM_get_str$(men.nam) <> "-"
        _MEMPUT gui(sel).menu, gui(sel).menu.OFFSET + len(tempm) * (gui(sel).selected - 1), tempm
      end if
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  CASE CHR$(0) + CHR$(75) 'LEFT
    if gui(sel).element_type = GUI_INPUT_BOX OR gui(sel).element_type = GUI_TEXT_BOX then
      IF gui(sel).text_position > 0 THEN
        gui(sel).text_position = gui(sel).text_position - 1
        IF gui(sel).text_position < gui(sel).scroll_offset_hors THEN
          gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors - 1
        END IF
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        if GUI_shift_flag = 0 then
          gui(sel).text_sel_col1 = gui(sel).text_position
          gui(sel).text_sel_col2 = gui(sel).text_sel_col1
        else
          gui(sel).text_sel_col2 = gui(sel).text_position
        end if
      END IF
    ELSEIF gui(sel).element_type = GUI_DROP_DOWN or gui(sel).element_type = GUI_LIST_BOX then
      if gui(sel).flags AND GUI_FLAG_SCROLL_H then
        if gui(sel).scroll_offset_hors > 0 then
          gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors - 1
          gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
          GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        end if
      end if
    ELSEIF gui(sel).element_type = GUI_MENU then
      gui(sel).selected = gui(sel).selected - 1
      if gui(sel).selected = 0 then gui(sel).selected = gui(sel).length
      men = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), GUI_menu_item_type)
      men.selected = 1
      _MEMPUT gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), men
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  CASE CHR$(0) + CHR$(77) 'RIGHT
    if gui(sel).element_type = GUI_INPUT_BOX OR gui(sel).element_type = GUI_TEXT_BOX then
      IF (gui(sel).text_position < gui(sel).text.length AND gui(sel).element_type = GUI_INPUT_BOX) OR gui(sel).element_type = GUI_TEXT_BOX THEN
        gui(sel).text_position = gui(sel).text_position + 1
        IF gui(sel).text_position > gui(sel).scroll_offset_hors + (gui(sel).col2 - gui(sel).col1 - 1) THEN
          gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors + 1
        END IF
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        if GUI_shift_flag = 0 then
          gui(sel).text_sel_col1 = gui(sel).text_position
          gui(sel).text_sel_col2 = gui(sel).text_sel_col1
        else
          gui(sel).text_sel_col2 = gui(sel).text_position
        end if
      end if
    ELSEIF gui(sel).element_type = GUI_DROP_DOWN or gui(sel).element_type = GUI_LIST_BOX then
      if gui(sel).flags AND GUI_FLAG_SCROLL_H then
        if gui(sel).scroll_offset_hors < gui(sel).scroll_max_hors - (gui(sel).col2 - gui(sel).col1 - 1) then
          gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors + 1
          gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
          GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        end if
      end if
    ELSEIF gui(sel).element_type = GUI_MENU then
      gui(sel).selected = (gui(sel).selected mod gui(sel).length) + 1
      men = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), GUI_menu_item_type)
      men.selected = 1
      _MEMPUT gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), men
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    END IF
  CASE CHR$(0) + CHR$(73) 'PageUp
    if gui(sel).element_type = GUI_LIST_BOX OR gui(sel).element_type = GUI_TEXT_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND (gui(sel).flags AND GUI_FLAG_DROP_FLAG))  then
      gui(sel).selected = gui(sel).selected - (gui(sel).row2 - gui(sel).row1 - 1)
      if gui(sel).selected < 1 then gui(sel).selected = 1
      GUI_fix_scroll gui(sel)
      GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  CASE CHR$(0) + CHR$(81) 'PageDown
    if gui(sel).element_type = GUI_LIST_BOX OR gui(sel).element_type = GUI_TEXT_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND (gui(sel).flags AND GUI_FLAG_DROP_FLAG)) then
      gui(sel).selected = gui(sel).selected + (gui(sel).row2 - gui(sel).row1 - 1)
      if gui(sel).selected > gui(sel).length then gui(sel).selected = gui(sel).length
      GUI_fix_scroll gui(sel)
      GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  CASE else 'CHR$(0) + CHR$(16) TO CHR$(0) + CHR$(50) 'Alt code
    if GUI_alt_flag and len(ch$) = 2 and NOT GUI_ctl_flag then
      k$ = GUI_alt_codes$(ASC(ch$, 2))
      if gui(sel).element_type = GUI_MENU and GUI_alt_flag then
        if gui(sel).flags AND GUI_FLAG_MENU_ALT then
          for x = 1 to gui(sel).length
            men = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
            if ucase$(k$) = ucase$(GUI_menu_char$(MEM_get_str$(men.nam))) then
              gui(sel).selected = x
              gui(sel).flags = (gui(sel).flags OR GUI_FLAG_MENU_OPEN OR GUI_FLAG_UPDATED) AND NOT GUI_FLAG_MENU_ALT
              men.selected = 1
              _MEMPUT gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (x - 1), men
            end if
          next x
        elseif gui(sel).flags AND GUI_FLAG_MENU_OPEN then
          men = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), GUI_menu_item_type)
          for x = 1 to men.sub_menu_length
            tempm = _MEMGET(men.sub_menu, men.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
            if ucase$(k$) = ucase$(GUI_menu_char$(MEM_get_str$(tempm.nam))) then
              gui(sel).menu_choice = tempm.ident
              gui(sel).flags = (gui(sel).flags OR GUI_FLAG_UPDATED OR GUI_FLAG_MENU_CHOSEN) AND NOT GUI_FLAG_MENU_OPEN
              gui(sel).selected = 0
            end if
          next x
        end if
      end if
    elseif GUI_ctl_flag and NOT GUI_alt_flag then
      if ch$ = chr$(22) then 'CTRL + V
        GUI_debug_output "Paste"
        SELECT CASE gui(sel).element_type
          CASE GUI_INPUT_BOX
            GUI_add_character gui(sel), _CLIPBOARD$
            gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
        END SELECT
      elseif ch$ = chr$(3) then 'CTRL + C
        GUI_debug_output "Copy"
        SELECT CASE gui(sel).element_type
          CASE GUI_INPUT_BOX
            t$ = MEM_get_str$(gui(sel).text)
            _CLIPBOARD$ = mid$(t$, gui(sel).text_sel_col1 + 1, gui(sel).text_sel_col2 - gui(sel).text_sel_col1)
        END SELECT
      elseif ch$ = chr$(24) then 'CTRL + X
        GUI_debug_output "Cut"
        SELECT CASE gui(sel).element_type
          CASE GUI_INPUT_BOX
            t$ = MEM_get_str$(gui(sel).text)
            _CLIPBOARD$ = mid$(t$, gui(sel).text_sel_col1 + 1, gui(sel).text_sel_col2 - gui(sel).text_sel_col1)
            GUI_del_character gui(sel)
            gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
        END SELECT
      end if
    end if
END SELECT

GUI_inkey$ = ch$

END FUNCTION

FUNCTION GUI_move_to_next_gui (movement$, current_selected, gui() AS GUI_element_type, gui_num AS INTEGER)
'function moves to next gui based on
selected_row = gui(current_selected).row1
selected_col = gui(current_selected).col1
new_col = -1 'distance from selected object
new_row = -1
new_gui = -1
'DIM choices(UBOUND(gui)) AS INTEGER
'things are judged by distance
'in event that there are more then one selected item, which normally happens, we select the closer object

SELECT CASE movement$
  CASE CHR$(0) + CHR$(72) 'up
    FOR x = 1 TO gui_num
      IF gui(x).row1 < selected_row AND gui(x).row1 >= new_row THEN
        IF gui(x).col1 = new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_col = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).col1 < new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(80) 'down
    FOR x = 1 TO gui_num
      IF gui(x).row1 > selected_row AND (gui(x).row1 <= new_row OR new_row = -1) THEN
        IF gui(x).col1 = new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_col = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).col1 < new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(75) 'left
    FOR x = 1 TO gui_num
      IF gui(x).col1 < selected_col AND (gui(x).col1 >= new_col) THEN
        IF gui(x).row1 = new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_row = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).row1 > new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(77) 'right
    FOR x = 1 TO gui_num
      IF gui(x).col1 > selected_col AND (gui(x).col1 <= new_col OR new_col = -1) THEN
        IF gui(x).row1 = new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_row = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).row1 < new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
END SELECT
move_to_next_gui = new_gui
END FUNCTION


'###############################################################################
'###############################################################################
'#------------------------------MOUSE FUNCTIONS--------------------------------#
'###############################################################################
'###############################################################################


'returns a clicked on item
FUNCTION GUI_mouse_range (b() AS GUI_element_type, boxnum, selected_gui) 'Checks if mouse is in one of the boxes in b()
'Returns the array number if it is in one of them

DIM men as GUI_menu_item_type, mtmp as GUI_menu_item_type, mnext as GUI_menu_item_type
DIM memtmp AS _MEM, offset as _OFFSET

'GUI_butflag is a flag indicating if we've already handled the current mouse click
'GUI_butflag equals -1 when the mouse button is pressed and that press has already been handled
'By that logic, if GUI_butflag and GUI_but are both -1, then the mouse-button is being held-down
'It prevents holding the mouse-button down from being interperated as lots and lots of mouse clicks

s = GUI_read_mouse_queue
if s > 0 then
  GUI_mouse_range = s
  GUI_debug_output "Read Queue'd mouse: " + str$(s)
  EXIT FUNCTION
end if

GUI_mscroll = 0
DO WHILE _MOUSEINPUT
  GUI_mscroll = GUI_mscroll + _MOUSEWHEEL
  GUI_mx = _MOUSEX
  GUI_my = _MOUSEY
  GUI_but = _MOUSEBUTTON(1)
LOOP
IF GUI_mscroll and NOT GUI_but then 'handle scrolling
  IF b(selected_gui).element_type = GUI_LIST_BOX OR b(selected_gui).element_type = GUI_TEXT_BOX OR (b(selected_gui).element_type = GUI_DROP_DOWN AND (b(selected_gui).flags AND GUI_FLAG_DROP_FLAG)) then 'List box or open Drop-Down
    b(selected_gui).scroll_offset_vert = b(selected_gui).scroll_offset_vert + GUI_mscroll
    if b(selected_gui).scroll_offset_vert < 0 then b(selected_gui).scroll_offset_vert = 0
    if b(selected_gui).scroll_offset_vert > b(selected_gui).length - (b(selected_gui).row2 - b(selected_gui).row1 - 1) then
      b(selected_gui).scroll_offset_vert = b(selected_gui).length - (b(selected_gui).row2 - b(selected_gui).row1 - 1)
    end if
    GUI_calc_scroll b(selected_gui).row1, b(selected_gui).col1, b(selected_gui).row2, b(selected_gui).col2, b(selected_gui)
    b(selected_gui).flags = b(selected_gui).flags OR GUI_FLAG_UPDATED
  END IF
END IF
IF GUI_but AND GUI_butflag THEN 'Mouse held
  'IF b(selected_gui).element_type = GUI_LIST_BOX OR b(selected_gui).element_type = GUI_TEXT_BOX or (b(selected_gui).element_type = GUI_DROP_DOWN AND b(selected_gui).drop_flag) then
  if b(selected_gui).flags AND GUI_FLAG_SCROLL_IS_HELD_H then 'hors
    if b(selected_gui).scroll_loc_hors <> GUI_mx then
      b(selected_gui).scroll_loc_hors = GUI_mx
      if b(selected_gui).scroll_loc_hors - b(selected_gui).col1 - 2 < 0 then
        b(selected_gui).scroll_loc_hors = b(selected_gui).col1 + 2
      end if
      if b(selected_gui).scroll_loc_hors > b(selected_gui).col2 - 2 then
        b(selected_gui).scroll_loc_hors = b(selected_gui).col2 - 2
      end if
      GUI_calc_hors_offset b(selected_gui)
      b(selected_gui).flags = b(selected_gui).flags OR GUI_FLAG_UPDATED
    end if
  elseif b(selected_gui).flags AND GUI_FLAG_SCROLL_IS_HELD_V then 'vert
    if b(selected_gui).scroll_loc_vert <> GUI_my then
      b(selected_gui).scroll_loc_vert = GUI_my
      if b(selected_gui).scroll_loc_vert - b(selected_gui).row1 - 2 < 0 then
        b(selected_gui).scroll_loc_vert = b(selected_gui).row1 + 2
      end if
      if b(selected_gui).scroll_loc_vert > b(selected_gui).row2 - 2 then
        b(selected_gui).scroll_loc_vert = b(selected_gui).row2 - 2
      end if
      GUI_calc_vert_offset b(selected_gui)
      b(selected_gui).flags = b(selected_gui).flags OR GUI_FLAG_UPDATED
    end if
  elseif b(selected_gui).element_type = GUI_INPUT_BOX then
    old_col = b(selected_gui).text_position
    if GUI_mx <= b(selected_gui).col1 then
      if b(selected_gui).scroll_offset_hors > 0 then
        if TIMER(.001) - GUI_DRAG_TIMER > .05 then
          b(selected_gui).scroll_offset_hors = b(selected_gui).scroll_offset_hors - 1
          b(selected_gui).text_position = b(selected_gui).scroll_offset_hors
          b(selected_gui).text_sel_col2 = b(selected_gui).text_position
          b(selected_gui).flags = b(selected_gui).flags OR GUI_FLAG_UPDATED
          GUI_DRAG_TIMER = TIMER(.001)
        end if
      end if
    elseif GUI_mx >= b(selected_gui).col2 then
      if b(selected_gui).scroll_offset_hors - (b(selected_gui).col2 - b(selected_gui).col1) < b(selected_gui).length + 1 then
        if TIMER(.001) - GUI_DRAG_TIMER > .05 then
          b(selected_gui).scroll_offset_hors = b(selected_gui).scroll_offset_hors + 1
          b(selected_gui).text_position = b(selected_gui).scroll_offset_hors + (b(selected_gui).col2 - b(selected_gui).col1 - 1)
          b(selected_gui).text_sel_col2 = b(selected_gui).text_position
          b(selected_gui).flags = b(selected_gui).flags OR GUI_FLAG_UPDATED
          GUI_DRAG_TIMER = TIMER(.001)
        end if
      end if
    else
      b(selected_gui).text_position = b(selected_gui).scroll_offset_hors + GUI_mx - b(selected_gui).col1 - 1
      IF b(selected_gui).text_position > b(selected_gui).text.length THEN
        b(selected_gui).text_position = b(selected_gui).text.length
      END IF
      'if b(selected_gui).flags AND GUI_FLAG_TEXT_IS_SELECTED THEN
      'if GUI_my - b(selected_gui).col1 <> b(selected_gui).text_sel_col1 then
        'c = GUI_my - b(selected_gui).col1
        'if c + b(selected_gui).scroll_offset_hors > b(selected_gui).text.length then
        '  c = b(selected_gui).text.length - b(selected_gui).scroll_offset_hors
        'end if
      if old_col <> b(selected_gui).text_position then
        b(selected_gui).text_sel_col2 = b(selected_gui).text_position
        b(selected_gui).flags = b(selected_gui).flags OR GUI_FLAG_UPDATED' OR GUI_FLAG_TEXT_IS_SELECTED
      end if
        'c = GUI_my - b(selected_gui).col1
        'if c + b(selected_gui).scroll_offset_hors > b(selected_gui).text.length then
        '  c = b(selected_gui).text.length - b(selected_gui).scroll_offset_hors
        'end if
      '  b(selected_gui).text_sel_col1 = old_cel
      '  b(selected_gui).text_sel_col2 = b(selected_gui).text_position
      'end if
      'if b(selected_gui).text_sel_col1 > b(selected_gui).text_sel_col2 then
      '  swap b(selected_gui).text_sel_col1, b(selected_gui).text_sel_col2
      'end if
    end if
  end if
    'if GUI_mx = b(selected_gui).col2 AND (b(selected_gui).scroll AND 1) then
    '  if GUI_my >= b(selected_gui).row1 + 2 and GUI_my <= b(selected_gui).row2 - 2 then
    '    b(selected_gui).scroll_loc_vert = GUI_my
    '    b(selected_gui).scroll_offset_vert = ((GUI_my - b(selected_gui).row1 - 2) / (b(selected_gui).row2 - b(selected_gui).row1 - 2)) * (b(selected_gui).length - (b(selected_gui).row2 - b(selected_gui).row1 - 4))
    '  end if
    'elseif GUI_my = b(selected_gui).row2 AND (b(selected_gui).scroll AND 2) then
    '  if GUI_mx >= b(selected_gui).col1 + 2 and GUI_mx <= b(selected_gui).col2 - 2 then
    '    b(selected_gui).scroll_loc_hors = GUI_mx
    '    b(selected_gui).scroll_offset_hors = ((GUI_mx - b(selected_gui).col1 - 2) / (b(selected_gui).col2 - b(selected_gui).col1 - 2)) * (b(selected_gui).scroll_max_hors - (b(selected_gui).col2 - b(selected_gui).col1 - 4))
    '  end if
    'end if
  'end if
  EXIT FUNCTION
ELSEIF GUI_butflag then
  GUI_butflag = 0
  b(selected_gui).flags = ((b(selected_gui).flags AND NOT GUI_FLAG_SCROLL_IS_HELD_H) AND NOT GUI_FLAG_SCROLL_IS_HELD_V) OR GUI_FLAG_UPDATED
END IF
IF GUI_but = 0 THEN EXIT FUNCTION
GUI_butflag = -1
current_layer = -128
found = 0
FOR x = 1 TO boxnum
  k = GUI_get_layer(b(x))
  if k > current_layer then
    select case b(x).element_type
      case GUI_BOX
        IF GUI_my <= b(x).row2 AND GUI_my >= b(x).row1 THEN
          IF GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col2 THEN
            found = x
            current_layer = k
          END IF
        END IF
      case GUI_INPUT_BOX
        IF GUI_my <= b(x).row1 + 2 AND GUI_my >= b(x).row1 THEN
          IF GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col2 THEN
            found = x
            current_layer = k
          END IF
        END IF
      case GUI_LIST_BOX, GUI_TEXT_BOX
        IF GUI_my <= b(x).row2 AND GUI_my >= b(x).row1 THEN
          IF GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col2 THEN
            found = x
            current_layer = k
          END IF
        END IF
      case GUI_DROP_DOWN
        if (b(x).flags AND GUI_FLAG_DROP_FLAG) <> GUI_FLAG_DROP_FLAG then
          'GUI_debug_output "Result: " + str$(NOT (b(x).flags AND GUI_FLAG_DROP_FLAG))
          IF GUI_my = b(x).row1 AND GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col2 THEN
            found = x
            current_layer = k
          END IF
        else
          if GUI_my >= b(x).row1 and GUI_my <= b(x).row2 and GUI_mx >= b(x).col1 and GUI_mx <= b(x).col2 then
            found = x
            current_layer = k
          end if
        end if
      case GUI_CHECKBOX
        IF GUI_my = b(x).row1 AND GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col1 + 2 + b(x).nam.length THEN
          found = x
          current_layer = k
        END IF
      case GUI_MENU
        if GUI_menu_clicked_on(b(x), GUI_MX, GUI_MY, debth, selection) then
          found = x
          current_layer = k
        end if
        'if GUI_my = b(x).row1 then
        '  found = x 
        '  current_layer = k
        'elseif b(x).flags AND GUI_FLAG_MENU_OPEN then
        '  col1 = b(x).col1 + b(x).menu_padding - 1 'Find row and column locations of the open menu
        '  row1 = b(x).row1 + 1
        '  if (b(x).flags AND GUI_FLAG_MENU_LAST_ON_RIGHT) = 0 OR b(x).selected <> b(x).length then
        '    for m = 1 to b(x).selected
        '      men = _MEMGET(b(x).menu, b(x).menu.OFFSET + len(men) * (m - 1), GUI_menu_item_type)
        '      if m < b(x).selected then col1 = col1 + men.nam.length + 1
        '    next m
        '  else
        '    men = _MEMGET(b(x).menu, b(x).menu.OFFSET + len(men) * (b(x).length - 1), GUI_menu_item_type)
        '    col1 = b(x).col2 - men.nam.length - 2
        '    if b(x).flags AND GUI_FLAG_SHADOW then col1 = col1 - 2
        '  end if
        '  GUI_get_menu_location b(x), men, row1, col1, row2, col2
        '  wid = col2 - col1 - 3
        '  if GUI_my >= row1 and GUI_my <= row2 then
        '    if GUI_mx >= col1 and GUI_mx <= col2 then
        '      found = x
        '      current_layer = k
        '    end if
        '  end if
        'end if
      case GUI_BUTTON
        IF GUI_my = b(x).row1 AND GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col1 + b(x).nam.length + 1 THEN
          found = x
          current_layer = k
        END IF
      case GUI_RADIO_BUTTON
        if GUI_my = b(x).row1 AND GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col1 + 2 + b(x).nam.length THEN
          found = x
          current_layer = k
        end if
      CASE GUI_LABEL
        IF GUI_my = b(x).row1 and GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col1 + b(x).text.length then
          found = x
          current_layer = k
        end if
    END SELECT
  end if
NEXT x

GUI_mouse_range = found

if found > 0 then
  GUI_debug_output "Click:" + str$(found)
  select case b(found).element_type
    case GUI_BOX
      selected_gui = found
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED
    case GUI_INPUT_BOX
      selected_gui = found
      IF GUI_my = b(found).row1 + 1 THEN
        IF GUI_mx > b(found).col1 + 1 AND GUI_mx < b(found).col2 - 1 THEN
          b(found).text_position = b(found).scroll_offset_hors + GUI_mx - b(found).col1 - 1
          IF b(found).text_position > b(found).text.length THEN
            b(found).text_position = b(found).text.length
          END IF
        END IF
      END IF
      if NOT GUI_shift_flag then
        b(found).text_sel_col1 = b(found).text_position
      end if
      b(found).text_sel_col2 = b(found).text_position
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED
    case GUI_TEXT_BOX
      selected_gui = found
      IF GUI_my >= b(found).row1 + 1 and GUI_my <= b(found).row2 - 1 THEN
        IF GUI_mx >= b(found).col1 + 1 AND GUI_mx <= b(found).col2 - 1 THEN
          b(found).selected = GUI_my - b(found).row1 + b(found).scroll_offset_vert
          b(found).text_position = b(found).scroll_offset_hors + GUI_mx - b(found).col1 - 1
          if b(found).selected > b(found).length then
            b(found).selected = b(found).length
          end if
        END IF
      END IF
      check_scroll = -1
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED
    case GUI_LIST_BOX
      selected_gui = found
      IF GUI_my >= b(found).row1 + 1 and GUI_my <= b(found).row2 - 1 THEN
        IF GUI_mx >= b(found).col1 + 1 AND GUI_mx <= b(found).col2 - 1 then
          s = GUI_my - b(found).row1 + b(found).scroll_offset_vert
          if b(found).selected <> s then
            b(found).selected = s
          end if
        END IF
      END IF
      if b(found).selected > b(found).length then b(found).selected = b(found).length
      check_scroll = -1
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED
    case GUI_DROP_DOWN
      if selected_gui = found and GUI_my = b(found).row1 then
        b(found).flags = b(found).flags XOR GUI_FLAG_DROP_FLAG
      end if
      if b(found).flags AND GUI_FLAG_DROP_FLAG then
        IF GUI_my >= b(found).row1 + 1 and GUI_my <= b(found).row2 - 1 THEN
          IF GUI_mx >= b(found).col1 + 1 AND GUI_mx <= b(found).col2 - 1 THEN
            s = GUI_my - b(found).row1 + b(found).scroll_offset_vert
            if s = b(found).selected then
              b(found).flags = (b(found).flags AND NOT GUI_FLAG_DROP_FLAG)
            else
              b(found).selected = s
            end if
          END IF
        END IF
        check_scroll = -1
      end if
      selected_gui = found
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED
    case GUI_CHECKBOX
      if GUI_mx = b(found).col1 + 1 then b(found).flags = b(found).flags XOR GUI_FLAG_CHECKED
      selected_gui = found
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED
    CASE GUI_RADIO_BUTTON
      if GUI_mx = b(found).col1 + 1 then
        b(found).flags = b(found).flags OR GUI_FLAG_CHECKED
        FOR x = 1 to boxnum
          if x <> found then
            if b(x).element_type = GUI_RADIO_BUTTON then
              if b(x).group = b(found).group then
                b(x).flags = b(x).flags AND NOT GUI_FLAG_CHECKED
              end if
            end if
          end if
        NEXT x
      end if
      selected_gui = found
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED
    case GUI_MENU
      if selected_gui <> found then b(found).selected = 0: b(found).flags = b(found).flags AND NOT GUI_FLAG_MENU_OPEN
      selected_gui = found
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED
      GUI_debug_output "CHECK Debth: " + str$(debth) + " Sel: " + str$(selection)
      if debth = 0 then
        if selection > 0 then
          b(found).flags = b(found).flags OR GUI_FLAG_MENU_OPEN
          b(found).selected = selection
          men = _MEMGET(b(found).menu, b(found).menu.OFFSET + len(men) * (b(found).selected - 1), GUI_menu_item_type)
          if men.has_sub then
            men.sub_menu_open = -1
            GUI_close_sub_menu men
          end if
          men.selected = 1
          _MEMPUT b(found).menu, b(found).menu.OFFSET + len(men) * (b(found).selected - 1), men
        else
          b(found).selected = 0
          b(found).flags = b(found).flags AND NOT GUI_FLAG_MENU_OPEN
        end if
      else
        GUI_debug_output "Selecting up menu"
        GUI_debug_output "Selection: " + str$(selection)
        memtmp = b(found).menu
        offset = len(mtmp) * (b(found).selected - 1)
        mtmp = _MEMGET(b(found).menu, b(found).menu.OFFSET + len(mtmp) * (b(found).selected - 1), GUI_menu_item_type)
        GUI_Debug_output "BMTMP: " + MEM_get_str$(mtmp.nam)
        '_MEMPUT memtmp, memtmp.OFFSET + offset, mtmp
        FOR d = 1 to debth - 1
          'if d >= debth - 1 then mtmp.selected = selection
          'if d < debth  then
          men = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(men) * (mtmp.selected - 1), GUI_menu_item_type)
          'else
          '  men = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(men) * (selection - 1), GUI_menu_item_type)
          'end if
          if d < debth then
            GUI_debug_output "I was here!"
            memtmp = mtmp.sub_menu
            offset = len(mtmp) * (mtmp.selected - 1)
            mtmp = men
          end if
        
        NEXT d
        mtmp.selected = selection
        GUI_Debug_output "MTMP: " + MEM_get_str$(mtmp.nam)
        GUI_Debug_output "MOFF: " + str$(b(found).menu.OFFSET) + " memtmp:" + str$(memtmp.OFFSET)
        GUI_debug_output "OFF:  " + str$(offset)
        _MEMPUT memtmp, memtmp.OFFSET + offset, mtmp
        men = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(men) * (mtmp.selected - 1), GUI_menu_item_type)
        
        GUI_debug_output "Menu Item: " + MEM_get_str$(men.nam)
        'mtmp.selected = selection
        if men.has_Sub then
          'mnext = _MEMGET(men.sub_menu, men.sub_menu.OFFSET + len(men) * (men.selected - 1), GUI_menu_item_type)
          'if mnext.has_sub then
          men.sub_menu_open = -1
          men.selected = 1
          GUI_close_sub_menu men
          'mnext.selected = 1
          '_MEMPUT men.sub_menu, men.sub_menu.OFFSET + len(mnext) * (men.selected - 1), mnext
          _MEMPUT mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(men) * (mtmp.selected - 1), men
        else
          b(found).menu_choice = men.ident
          b(found).selected = 0
          b(found).flags = (b(found).flags OR GUI_FLAG_MENU_CHOSEN OR GUI_FLAG_UPDATED) AND NOT GUI_FLAG_MENU_OPEN
        end if
      end if
      'if GUI_my = b(found).row1 then
      '  c = b(found).col1 + b(found).menu_padding
      '  for x = 1 to b(found).length
      '    men = _MEMGET(b(found).menu, b(found).menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
      '    if x = b(found).length AND (b(found).flags AND GUI_FLAG_MENU_LAST_ON_RIGHT) then
      '      c = b(found).col2 - GUI_menu_len(MEM_get_str$(men.nam)) - 2
      '    end if
      '    if GUI_mx >= c and GUI_mx <= c + GUI_menu_len(MEM_get_str$(men.nam)) + 2 then
      '      b(found).selected = x
      '      b(found).flags = b(found).flags OR GUI_FLAG_MENU_OPEN
      '      men.selected = 1
      '      GUI_close_sub_menu men
      '      _MEMPUT b(found).menu, b(found).menu.OFFSET + len(men) * (x - 1), men
      '    end if
      '    c = c + 2 + GUI_menu_len(MEM_get_str$(men.nam))
      '  next x
      'elseif b(found).flags AND GUI_FLAG_MENU_OPEN then
      '  men = _MEMGET(b(found).menu, b(found).menu.OFFSET + len(men) * (b(found).selected - 1), GUI_menu_item_type)
      '  if GUI_my > row1 and GUI_my < row2 then
      '    if GUI_mx > col1 and GUI_mx < col2 then
      '      s = GUI_my - row1
      '      mtmp = _MEMGET(men.sub_menu, men.sub_menu.OFFSET + len(men) * (s - 1), GUI_menu_item_type)
      '      if MEM_get_str$(mtmp.nam) <> "-" then
      '        mtmp.selected = s
      '        b(found).selected = 0
      '        b(found).flags = (b(found).flags OR GUI_FLAG_MENU_CHOSEN) AND NOT GUI_FLAG_MENU_OPEN
      '        b(found).menu_choice = mtmp.ident
      '      end if
      '    end if
      '  end if
      'end if
    case GUI_BUTTON
      selected_gui = found
      b(found).flags = b(found).flags OR GUI_FLAG_UPDATED

  END SELECT
  if check_scroll then
    if b(found).flags AND GUI_FLAG_SCROLL_H then
      if GUI_my = b(found).row2 then
        if GUI_mx = b(found).col1 + 1 then
          if b(found).scroll_offset_hors > 0 then
            b(found).scroll_offset_hors = b(found).scroll_offset_hors - 1
            calc_flag = -1
          end if
        elseif GUI_mx = b(found).col2 - 1 then
          if b(found).scroll_offset_hors < (b(found).scroll_max_hors - (b(found).col2 - b(found).col1 - 1)) then
            b(found).scroll_offset_hors = b(found).scroll_offset_hors + 1
            calc_flag = -1
          end if
        elseif GUI_mx = b(found).scroll_loc_hors then
          b(found).flags = b(found).flags OR GUI_FLAG_SCROLL_IS_HELD_H
        end if
      end if
    end if
    if b(found).flags AND GUI_FLAG_SCROLL_V then
      if GUI_mx = b(found).col2 then
        if GUI_my = b(found).row1 + 1 then
          if b(found).scroll_offset_vert > 0 then
            b(found).scroll_offset_vert = b(found).scroll_offset_vert - 1
            calc_flag = -1
          end if
        elseif GUI_my = b(found).row2 - 1 then
          if b(found).scroll_offset_vert < (b(found).length - (b(found).row2 - b(found).row1 - 1)) then
            b(found).scroll_offset_vert = b(found).scroll_offset_vert + 1
            calc_flag = -1
          end if
        elseif GUI_my = b(found).scroll_loc_vert then
          b(found).flags = b(found).flags OR GUI_FLAG_SCROLL_IS_HELD_V
        end if
      end if
    end if
  end if
  if calc_flag then GUI_calc_scroll b(found).row1, b(found).col1, b(found).row2, b(found).col2, b(found)
end if

END SUB

'Records the GUI number sel to be queued up for a mouse click
'This happens for things such as pressing enter on a button
SUB GUI_queue_mouse_click (sel)
GUI_MOUSE_QUEUE$ = ltrim$(rtrim$(str$(sel))) + " " + GUI_MOUSE_QUEUE$
END SUB

'This function returns a queued mouse event, if one is there.
FUNCTION GUI_read_mouse_queue ()
if GUI_MOUSE_QUEUE$ > "" then
  s = val(GUI_MOUSE_QUEUE$)
  GUI_MOUSE_QUEUE$ = mid$(GUI_MOUSE_QUEUE$, instr(GUI_MOUSE_QUEUE$, " ") + 1)
  GUI_read_mouse_queue = s
end if
END FUNCTION
