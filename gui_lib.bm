'FTP Client
'Copyright Matt Kilgore -- 2011/2013

'This program is free software, without any warranty of any kind.
'You are free to edit, copy, modify, and redistribute it under the terms
'of the Do What You Want Public License, Version 1, as published by Matt Kilgore
'See file COPYING that should have been included with this source.

SUB GUI_init()
a$ = "QWERTYUIOP????ASDFGHJKL?????ZXCVBNM" 'Credit to Galleon for the ALT key code stuff.
FOR x = 1 TO LEN(a$)
  GUI_alt_codes$(x + 15) = MID$(a$, x, 1)
NEXT x
GUI_DEFAULT_COLOR_BOX.mcolor.fr = 7
GUI_DEFAULT_COLOR_BOX.mcolor.bk = 1
GUI_DEFAULT_COLOR_BOX.selcolor.fr = 1
GUI_DEFAULT_COLOR_BOX.selcolor.bk = 7
GUI_DEFAULT_COLOR_BUTTON.mcolor.fr = 7
GUI_DEFAULT_COLOR_BUTTON.mcolor.bk = 1
GUI_DEFAULT_COLOR_BUTTON.selcolor.fr = 15
GUI_DEFAULT_COLOR_BUTTON.selcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.mcolor.fr = 7
GUI_DEFAULT_COLOR_DROP.mcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.selcolor.fr = 15
GUI_DEFAULT_COLOR_DROP.selcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.scroll_color.fr = 0
GUI_DEFAULT_COLOR_DROP.scroll_color.bk = 7
GUI_DEFAULT_COLOR_CHECKBOX.mcolor.fr = 7
GUI_DEFAULT_COLOR_CHECKBOX.mcolor.bk = 1
GUI_DEFAULT_COLOR_CHECKBOX.selcolor.fr = 15
GUI_DEFAULT_COLOR_CHECKBOX.selcolor.bk = 1
GUI_DEFAULT_COLOR_INPUT.mcolor.fr = 7
GUI_DEFAULT_COLOR_INPUT.mcolor.bk = 1
GUI_DEFAULT_COLOR_INPUT.selcolor.fr = 1
GUI_DEFAULT_COLOR_INPUT.selcolor.bk = 7
GUI_DEFAULT_COLOR_LIST.mcolor.fr = 7
GUI_DEFAULT_COLOR_LIST.mcolor.bk = 1
GUI_DEFAULT_COLOR_LIST.selcolor.fr = 15
GUI_DEFAULT_COLOR_LIST.selcolor.bk = 1
GUI_DEFAULT_COLOR_LIST.scroll_color.fr = 0
GUI_DEFAULT_COLOR_LIST.scroll_color.bk = 7
GUI_DEFAULT_COLOR_MENU.mcolor.fr = 7
GUI_DEFAULT_COLOR_MENU.mcolor.bk = 1
GUI_DEFAULT_COLOR_MENU.selcolor.fr = 1
GUI_DEFAULT_COLOR_MENU.selcolor.bk = 7
GUI_DEFAULT_COLOR_TEXT.mcolor.fr = 7
GUI_DEFAULT_COLOR_TEXT.mcolor.bk = 1
GUI_DEFAULT_COLOR_TEXT.selcolor.fr = 1
GUI_DEFAULT_COLOR_TEXT.selcolor.bk = 7
GUI_DEFAULT_COLOR_TEXT.scroll_color.fr = 0
GUI_DEFAULT_COLOR_TEXT.scroll_color.bk = 7
GUI_DEFAULT_COLOR_RADIO.mcolor.fr = 7
GUI_DEFAULT_COLOR_RADIO.mcolor.bk = 1
GUI_DEFAULT_COLOR_RADIO.selcolor.fr = 15
GUI_DEFAULT_COLOR_RADIO.selcolor.bk = 1
END SUB

FUNCTION GUI_move_to_next_gui (movement$, current_selected, gui() AS GUI_element_type, gui_num AS INTEGER)
'function moves to next gui based on
selected_row = gui(current_selected).row1
selected_col = gui(current_selected).col1
new_col = -1 'distance from selected object
new_row = -1
new_gui = -1
'DIM choices(UBOUND(gui)) AS INTEGER
'things are judged by distance
'in event that there are more then one selected item, which normally happens, we select the closer object

SELECT CASE movement$
  CASE CHR$(0) + CHR$(72) 'up
    FOR x = 1 TO gui_num
      IF gui(x).row1 < selected_row AND gui(x).row1 >= new_row THEN
        IF gui(x).col1 = new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_col = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).col1 < new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(80) 'down
    FOR x = 1 TO gui_num
      IF gui(x).row1 > selected_row AND (gui(x).row1 <= new_row OR new_row = -1) THEN
        IF gui(x).col1 = new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_col = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).col1 < new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(75) 'left
    FOR x = 1 TO gui_num
      IF gui(x).col1 < selected_col AND (gui(x).col1 >= new_col) THEN
        IF gui(x).row1 = new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_row = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).row1 > new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(77) 'right
    FOR x = 1 TO gui_num
      IF gui(x).col1 > selected_col AND (gui(x).col1 <= new_col OR new_col = -1) THEN
        IF gui(x).row1 = new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_row = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).row1 < new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
END SELECT
move_to_next_gui = new_gui
END FUNCTION

FUNCTION GUI_update_screen (gui() AS GUI_element_type, gui_num AS INTEGER, sel AS INTEGER)
FOR x = 1 to gui_num
  if gui(x).element_type = GUI_DROP_DOWN and x <> sel and gui(x).drop_flag then gui(x).drop_flag = 0: GUI_update_screen = -1
  if gui(x).updated then GUI_update_screen = -1
NEXT x
END FUNCTION

FUNCTION GUI_inkey$ (gui() AS GUI_element_type, gui_num AS INTEGER, sel)
ch$ = INKEY$
SELECT CASE ch$
  CASE " " TO "~" 'typeable character
    if gui(sel).element_type = GUI_INPUT_BOX then
      GUI_add_character gui(sel), ch$
      gui(sel).updated = -1
    elseif ch$ = " " and gui(sel).element_type = GUI_CHECKBOX then
      gui(sel).checked = not gui(sel).checked
    elseif ch$ = " " and gui(sel).element_type = GUI_RADIO_BUTTON then
      gui(sel).checked = not gui(sel).checked
      FOR x = 1 to gui_num
        if x <> sel then
          if gui(x).element_type = GUI_RADIO_BUTTON then
            if gui(x).group = gui(sel).group then
              gui(x).checked = 0
            end if
          end if
        end if
      NEXT x
    end if
  CASE CHR$(8) 'BACKSPACE
    if gui(sel).element_type = GUI_INPUT_BOX then
      GUI_del_character gui(sel)
      gui(sel).updated = -1
    end if
  CASE chr$(9) 'Tab
    do
      sel = (sel mod gui_num) + 1
    loop until gui(sel).skip = 0
    gui(sel).updated = -1
  CASE CHR$(0) + CHR$(80) 'DOWN
    if gui(sel).element_type = GUI_LIST_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND gui(sel).drop_flag) then
      if gui(sel).selected < gui(sel).length then
        gui(sel).selected = gui(sel).selected + 1
        GUI_fix_scroll gui(sel)
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        gui(sel).updated = -1
      end if
    ELSEIF gui(sel).element_type = GUI_DROP_DOWN then
      gui(sel).drop_flag = -1
    end if
  CASE CHR$(0) + CHR$(72) 'UP
    if gui(sel).element_type = GUI_LIST_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND gui(sel).drop_flag)  then
      if gui(sel).selected > 1 then
        gui(sel).selected = gui(sel).selected - 1
        GUI_fix_scroll gui(sel)
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        gui(sel).updated = -1
      end if
    end if
  CASE CHR$(0) + CHR$(75) 'LEFT
    if gui(sel).element_type = GUI_INPUT_BOX then
      IF gui(sel).text_position > 0 THEN
        gui(sel).text_position = gui(sel).text_position - 1
        IF gui(sel).text_position < gui(sel).text_offset THEN
          gui(sel).text_offset = gui(sel).text_offset - 1
        END IF
        gui(sel).updated = -1
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        'update_input_boxes = -1
      END IF
    ELSEIF gui(sel).element_type = GUI_DROP_DOWN or gui(sel).element_type = GUI_LIST_BOX then
      if gui(sel).scroll AND 2 then
        if gui(sel).scroll_offset_hors > 0 then
          gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors - 1
          gui(sel).updated = -1
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        end if
      end if
    end if
  CASE CHR$(0) + CHR$(77) 'RIGHT
    if gui(sel).element_type = GUI_INPUT_BOX then
      IF gui(sel).text_position < gui(sel).text.length THEN
        gui(sel).text_position = gui(sel).text_position + 1
        IF gui(sel).text_position > gui(sel).text_offset + (gui(sel).col2 - gui(sel).col1 - 1) THEN
          gui(sel).text_offset = gui(sel).text_offset + 1
        END IF
        gui(sel).updated = -1
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
      end if
    ELSEIF gui(sel).element_type = GUI_DROP_DOWN or gui(sel).element_type = GUI_LIST_BOX then
      if gui(sel).scroll AND 2 then
        if gui(sel).scroll_offset_hors < gui(sel).scroll_max_hors - (gui(sel).col2 - gui(sel).col1 - 1) then
          gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors + 1
          gui(sel).updated = -1
          GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        end if
      end if
    END IF
  CASE CHR$(0) + CHR$(73) 'PageUp
    if gui(sel).element_type = GUI_LIST_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND gui(sel).drop_flag)  then
      gui(sel).selected = gui(sel).selected - (gui(sel).row2 - gui(sel).row1 - 1)
      if gui(sel).selected < 1 then gui(sel).selected = 1
      GUI_fix_scroll gui(sel)
      GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
      gui(sel).updated = -1
    end if
  CASE CHR$(0) + CHR$(81) 'PageDown
    if gui(sel).element_type = GUI_LIST_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND gui(sel).drop_flag) then
      gui(sel).selected = gui(sel).selected + (gui(sel).row2 - gui(sel).row1 - 1)
      if gui(sel).selected > gui(sel).length then gui(sel).selected = gui(sel).length
      GUI_fix_scroll gui(sel)
      GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
      gui(sel).updated = -1
    end if
END SELECT
GUI_inkey$ = ch$
EXIT FUNCTION

END FUNCTION

'Inits an element without a parent
'While it doesn't do much now besides set some default colors, it may do more in the future
'It's recommended to use this SUB
SUB GUI_init_element (g as GUI_element_type, nam$)
put_str g.nam, nam$
SELECT CASE g.element_type
  case GUI_BOX
    g.mcolor = GUI_DEFAULT_COLOR_BOX.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_BOX.selcolor
  CASE GUI_BUTTON
    g.mcolor = GUI_DEFAULT_COLOR_BUTTON.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_BUTTON.selcolor
  CASE GUI_DROP_DOWN
    g.mcolor = GUI_DEFAULT_COLOR_DROP.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_DROP.selcolor
    g.scroll_color = GUI_DEFAULT_COLOR_DROP.scroll_color
  CASE GUI_CHECKBOX
    g.mcolor = GUI_DEFAULT_COLOR_CHECKBOX.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_CHECKBOX.selcolor
  CASE GUI_INPUT_BOX
    g.mcolor = GUI_DEFAULT_COLOR_INPUT.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_INPUT.selcolor
  CASE GUI_LIST_BOX
    g.mcolor = GUI_DEFAULT_COLOR_LIST.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_LIST.selcolor
    g.scroll_color = GUI_DEFAULT_COLOR_LIST.scroll_color
  CASE GUI_MENU
    g.mcolor = GUI_DEFAULT_COLOR_MENU.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_MENU.selcolor
  CASE GUI_TEXT_BOX
    g.mcolor = GUI_DEFAULT_COLOR_TEXT.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_TEXT.selcolor
    g.scroll_color = GUI_DEFAULT_COLOR_TEXT.scroll_color
  CASE GUI_RADIO_BUTTON
    g.mcolor = GUI_DEFAULT_COLOR_RADIO.mcolor
    g.selcolor = GUI_DEFAULT_COLOR_RADIO.selcolor
END SELECT
END SUB

SUB GUI_fix_scroll (gui AS GUI_element_type)
if gui.selected - 1 < gui.scroll_offset_vert then
  gui.scroll_offset_vert = gui.selected - 1
elseif gui.selected > gui.scroll_offset_vert + (gui.row2 - gui.row1 - 1) then
  gui.scroll_offset_vert = gui.selected  - (gui.row2 - gui.row1 - 1)
end if
if gui.scroll_offset_vert < 0 then gui.scroll_offset_vert = 0
if gui.scroll_offset_vert + (gui.row2 - gui.row1 - 1) > gui.length then 
  gui.scroll_offset_vert = gui.length - (gui.row2 - gui.row1 - 1)
end if
END SUB

'This will recalculate scroll bar locations
SUB GUI_calc_scroll (row1, col1, row2, col2, b as GUI_element_type)
IF b.scroll AND 1 THEN
  'scr_len = row2 - row1 - 2
  'if scr_len * 2 <= b.length then
  '  b.scroll_wid_vert = 1
  b.scroll_loc_vert = INT((b.scroll_offset_vert) / (b.length - (row2 - row1 - 1)) * (row2 - row1 - 4) + row1 + 2)
  'else
  '  b.scroll_wid_vert = scr_len * 2 - b.length
  '  b.scroll_loc_vert = INT((b.scroll_offset_vert) / (b.length - (row2 - row1 - 1)) * (row2 - row1 - 3 - b.scroll_wid_vert) + row1 + 2)
  'end if
end if
if b.scroll AND 2 then 
  'scr_len = col2 - col1 - 2
  'if scr_len * 2 <= b.scroll_max_hors then
  '  b.scroll_wid_hors = 1
  b.scroll_loc_hors = INT((b.scroll_offset_hors) / (b.scroll_max_hors - (col2 - col1 - 1)) * (col2 - col1 - 4) + col1 + 2)
  'else
  '  b.scroll_wid_hors = scr_len * 2 - b.scroll_max_hors - 1
  '  b.scroll_loc_hors = INT((b.scroll_offset_hors) / (b.scroll_max_hors - (col2 - col1 - 1)) * (col2 - col1 - 3 - b.scroll_wid_hors) + col1 + 2)
  'end if
end if
END SUB

SUB GUI_draw_box (row1, col1, row2, col2, b as GUI_element_type)
IF b.shadow THEN
  FOR x = row1 + 1 TO row2 + 1
    FOR y = col1 + 2 TO col2 + 2
      chr = SCREEN(x, y)
      colo = SCREEN(x, y, 1)
      LOCATE x, y
      COLOR colo MOD 8, 0
      PRINT CHR$(chr);
    NEXT y
  NEXT x
END IF
if (b.scroll AND 1) and (b.scroll_loc_vert = 0) then GUI_calc_scroll row1, col1, row2, col2, b
if (b.scroll AND 2) and (b.scroll_loc_hors = 0) then GUI_calc_scroll row1, col1, row2, col2, b
n$ = get_str$(b.nam)
COLOR b.mcolor.fr, b.mcolor.bk
LOCATE row1, col1
PRINT CHR$(218); CHR$(196); n$; STRING$(col2 - col1 - 2 - LEN(n$), 196); CHR$(191);
FOR x = row1 + 1 TO row2 - 1
  LOCATE x, col1
  COLOR b.mcolor.fr, b.mcolor.bk
  PRINT CHR$(179); SPACE$(col2 - col1 - 1);
  IF (b.scroll AND 1) = 0 THEN
    PRINT CHR$(179);
  END IF
  IF b.scroll AND 1 THEN
    COLOR b.scroll_color.fr, b.scroll_color.bk
    SELECT CASE x
      CASE row1 + 1
        PRINT CHR$(24);
      CASE row2 - 1
        PRINT CHR$(25);
      CASE ELSE
        IF b.scroll_loc_vert = x THEN
          PRINT CHR$(219);
        ELSE
          PRINT CHR$(176);
        END IF
    END SELECT
  END IF
NEXT x
COLOR b.mcolor.fr MOD 8, b.mcolor.bk
LOCATE row2, col1
print CHR$(192);
if (b.scroll AND 2) = 0 then
  PRINT STRING$(col2 - col1 - 1, 196);
else
  color b.scroll_color.fr, b.scroll_color.bk
  PRINT chr$(27);
  print string$(b.scroll_loc_hors - b.col1 - 2, 176);
  print chr$(219);
  print string$(b.col2 - b.scroll_loc_hors - 2, 176); chr$(26);
  COLOR b.mcolor.fr MOD 8, b.mcolor.bk
end if
print CHR$(217);
END SUB

FUNCTION GUI_draw_inside_text (b as GUI_element_type)
for x = 1 to b.row2 - b.row1 - 1
  locate x + b.row1, b.col1 + 1
  if (b.selected - b.scroll_offset_vert) = (x) then
    s = x
    color b.selcolor.fr, b.selcolor.bk
  else
    color b.mcolor.fr, b.mcolor.bk
  end if
  k$ = mid$(get_str_array$(b.lines, x + b.scroll_offset_vert), b.scroll_offset_hors + 1, b.col2 - b.col1 - 1)
  k$ = k$ + space$((b.col2 - b.col1 - 1) - len(k$))
  print k$;
next x
GUI_draw_inside_text = s
END FUNCTION

FUNCTION GUI_get_layer (b as GUI_element_type)
IF b.element_type <> GUI_DROP_DOWN AND b.element_type <> GUI_MENU then
  GUI_get_layer = b.layer
ELSEIF b.element_type = GUI_DROP_DOWN AND b.drop_flag then
  GUI_get_layer = 128
ELSEIF b.element_type = GUI_DROP_DOWN and b.drop_flag THEN
  GUI_get_layer = b.layer
ELSEIF b.element_type = GUI_MENU then

END IF
END FUNCTION

'Draws an array of elements
'  respects layering
'  Call's _DISPLAY at start and _AUTODISPLAY at the end
'  Locates the cursor to a proper spot (And stores the location)
SUB GUI_draw_element_array (b() as GUI_element_type, gui_num, selected_gui)
_DISPLAY
drawn_count = 0
FOR cur_layer = -128 to 128
  for x = 1 to gui_num
    if GUI_get_layer(b(x)) = cur_layer then
      GUI_draw_element b(x), selected_gui = x
      drawn_count = drawn_count + 1
    end if
    if drawn_count = gui_num then exit FOR
  next x
  if draw_count = gui_num then exit FOR
next cur_layer
if b(selected_gui).cur_row > 0 then
  locate b(selected_gui).cur_row, b(selected_gui).cur_col, 1
  GUI_cur_row = b(selected_gui).cur_row
  GUI_cur_col = b(selected_gui).cur_col
else
  locate ,,0
  GUI_cur_row = 0
END IF
_AUTODISPLAY
END SUB

'sel indiciates whether that box is a selected GUI element
'also -- as can be seen this is really just a wrapper around the real drawing SUB's
'SUB's are split up to simplify the process
SUB GUI_draw_element (b AS GUI_element_type, sel) 'Draws box b
'Draws a box
IF b.element_type = GUI_BOX THEN 'Plain box
  GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
  
ELSEIF b.element_type = GUI_INPUT_BOX THEN 'Input box
  GUI_draw_input_box b, sel
  
ELSEIF b.element_type = GUI_TEXT_BOX THEN 'TextBox -- not done yet
  GUI_draw_text_box b, sel
  
ELSEIF b.element_type = GUI_LIST_BOX THEN 'list box
  GUI_draw_list_box b, sel
  
ELSEIF b.element_type = GUI_DROP_DOWN THEN 'Dropdown
  GUI_draw_dropdown b, sel
  
ELSEIF b.element_type = GUI_CHECKBOX THEN 'Checkbox
  GUI_draw_checkbox b, sel
  
ELSEIF b.element_type = GUI_MENU THEN 'Menu
  GUI_draw_menu b, sel
  
ELSEIF b.element_type = GUI_BUTTON THEN 'Button
  GUI_draw_button b, sel
  
ELSEIF b.element_type = GUI_RADIO_BUTTON THEN 'Radio button
  GUI_draw_radio_button b, sel

END IF
END SUB

SUB GUI_draw_checkbox (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk ELSE COLOR b.mcolor.fr MOD 8, b.mcolor.bk
PRINT "[";
IF b.checked THEN PRINT chr$(251); ELSE PRINT " ";
PRINT "]";
COLOR b.mcolor.fr, b.mcolor.bk
PRINT get_str$(b.nam);
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_radio_button (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk ELSE COLOR b.mcolor.fr MOD 8, b.mcolor.bk
PRINT "(";
IF b.checked THEN PRINT chr$(254); ELSE PRINT " ";
PRINT ")";
COLOR b.mcolor.fr, b.mcolor.bk
PRINT get_str$(b.nam);
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_button (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk ELSE COLOR b.mcolor.fr MOD 8, b.mcolor.bk
PRINT "<";
'IF sel THEN COLOR b.selcol, b.c2 ELSE COLOR b.c1 MOD 8, b.c2
COLOR b.mcolor.fr, b.mcolor.bk
PRINT get_str$(b.nam);
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk ELSE COLOR b.mcolor.fr MOD 8, b.mcolor.bk
PRINT ">";
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_input_box (b as GUI_element_type, sel)

GUI_draw_Box b.row1, b.col1, b.row1 + 2, b.col2, b
LOCATE b.row1 + 1, b.col1 + 1
s$ = MID$(get_str$(b.text), b.text_offset + 1, b.col2 - b.col1 - 1)
IF NOT b.hide THEN PRINT s$; ELSE PRINT STRING$(LEN(s$), "*");
b.cur_row = b.row1 + 1
b.cur_col = b.col1 + 1 + b.text_position - b.text_offset
END SUB

SUB GUI_draw_dropdown (b as GUI_element_type, sel)
_CONTROLCHR OFF
LOCATE b.row1, b.col1
COLOR b.mcolor.fr, b.mcolor.bk
if b.drop_flag then
  GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
end if
IF NOT b.drop_flag THEN PRINT "[";
IF sel THEN COLOR b.selcolor.fr, b.selcolor.bk
locate b.row1, b.col1 + 1
PRINT LEFT$(get_str_array$(b.lines, b.selected) + SPACE$(b.col2 - b.col1), b.col2 - b.col1 - 2); CHR$(31);
COLOR b.mcolor.fr, b.mcolor.bk
IF NOT b.drop_flag THEN PRINT "]";
if b.drop_flag then
  s = GUI_draw_inside_text(b)
end if
_CONTROLCHR ON
if s = 0 then
  b.cur_row = 0
  b.cur_col = 0
else 
  b.cur_row = s + b.row1 
  b.cur_col = b.col1 + 1
end if
END SUB

SUB GUI_draw_menu (b as GUI_element_type, sel)
b.cur_row = 0
b.cur_col = 0
END SUB

SUB GUI_draw_list_box (b as GUI_element_type, sel)
GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
s = GUI_draw_inside_text(b)
if s > 0 then
  b.cur_row = b.row1 + s
  b.cur_col = b.col1 + 1
else
  b.cur_row = 0
end if
END SUB

SUB GUI_draw_text_box (b as GUI_element_type, sel) ' -- NOT DONE
b.cur_row = 0
b.cur_col = 0
END SUB

SUB GUI_mouse_range (b() AS GUI_element_type, boxnum, selected_gui) 'Checks if mouse is in one of the boxes in b()
'Returns the array number if it is in one of them

'GUI_butflag is a flag indicating if we've already handled the current mouse click
'GUI_butflag equals -1 when the mouse button is pressed and that press has already been handled
'By that logic, if GUI_butflag and GUI_but are both -1, then the mouse-button is being held-down
'It prevents holding the mouse-button down from being interperated as lots and lots of mouse clicks

GUI_mscroll = 0
DO WHILE _MOUSEINPUT
  GUI_mscroll = GUI_mscroll + _MOUSEWHEEL
  GUI_mx = _MOUSEX
  GUI_my = _MOUSEY
  GUI_but = _MOUSEBUTTON(1)
LOOP
IF GUI_mscroll and NOT GUI_but then 'handle scrolling
  IF b(selected_gui).element_type = GUI_BOX then 'plain box
  ELSEIF b(selected_gui).element_type = GUI_INPUT_BOX then 'Input box, nothing to do
  ELSEIF b(selected_gui).element_type = GUI_TEXT_BOX then 'Text-Box
  ELSEIF b(selected_gui).element_type = GUI_LIST_BOX OR (b(selected_gui).element_type = GUI_DROP_DOWN AND b(selected_gui).drop_flag) then 'List box or open Drop-Down
    b(selected_gui).scroll_offset_vert = b(selected_gui).scroll_offset_vert + GUI_mscroll
    if b(selected_gui).scroll_offset_vert < 0 then b(selected_gui).scroll_offset_vert = 0
    if b(selected_gui).scroll_offset_vert > b(selected_gui).length - (b(selected_gui).row2 - b(selected_gui).row1 - 1) then 
      b(selected_gui).scroll_offset_vert = b(selected_gui).length - (b(selected_gui).row2 - b(selected_gui).row1 - 1)
    end if
    GUI_calc_scroll b(selected_gui).row1, b(selected_gui).col1, b(selected_gui).row2, b(selected_gui).col2, b(selected_gui)
    b(selected_gui).updated = -1
  END IF
END IF
IF GUI_but AND GUI_butflag THEN 'Mouse held
  IF b(selected_gui).element_type = GUI_LIST_BOX or (b(selected_gui).element_type = GUI_DROP_DOWN AND b(selected_gui).drop_flag) then
    if GUI_mx = b(selected_gui).col2 AND (b(selected_gui).scroll AND 1) then
      if GUI_my >= b(selected_gui).row1 + 2 and GUI_my <= b(selected_gui).row2 - 2 then
        b(selected_gui).scroll_loc_vert = GUI_my
        b(selected_gui).scroll_offset_vert = ((GUI_my - b(selected_gui).row1 - 2) / (b(selected_gui).row2 - b(selected_gui).row1 - 2)) * (b(selected_gui).length - (b(selected_gui).row2 - b(selected_gui).row1 - 4))
      end if
    elseif GUI_my = b(selected_gui).row2 AND (b(selected_gui).scroll AND 2) then
      if GUI_mx >= b(selected_gui).col1 + 2 and GUI_mx <= b(selected_gui).col2 - 2 then
        b(selected_gui).scroll_loc_hors = GUI_mx
        b(selected_gui).scroll_offset_hors = ((GUI_mx - b(selected_gui).col1 - 2) / (b(selected_gui).col2 - b(selected_gui).col1 - 2)) * (b(selected_gui).scroll_max_hors - (b(selected_gui).col2 - b(selected_gui).col1 - 4))
      end if
    end if
  end if
  EXIT FUNCTION
ELSE
  GUI_butflag = 0
END IF
IF GUI_but = 0 THEN EXIT FUNCTION
GUI_butflag = -1
current_layer = -128
found = 0
FOR x = 1 TO boxnum
  k = GUI_get_layer(b(x))
  select case b(x).element_type
    case GUI_BOX 
      IF GUI_my <= b(x).row2 AND GUI_my >= b(x).row1 THEN
        IF GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col2 THEN
          if k > current_layer then
            found = x
            current_layer = k
          end if
        END IF
      END IF
    case GUI_INPUT_BOX
      IF GUI_my <= b(x).row1 + 2 AND GUI_my >= b(x).row1 THEN
        IF GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col2 THEN
          if k > current_layer then
            found = x
            current_layer = k
          end if
        END IF
      END IF
    case GUI_TEXT_BOX 
    case GUI_LIST_BOX
      IF GUI_my <= b(x).row2 AND GUI_my >= b(x).row1 THEN
        IF GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col2 THEN
          if k > current_layer then
            found = x
            current_layer = k
          end if
        END IF
      END IF
    case GUI_DROP_DOWN
      if NOT b(x).drop_flag then
        IF GUI_my = b(x).row1 AND GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col2 THEN
          if k > current_layer then
            found = x
            current_layer = k
          end if
        END IF
      else
        if GUI_my >= b(x).row1 and GUI_my <= b(x).row2 and GUI_mx >= b(x).col1 and GUI_mx <= b(x).col2 then
          if k > current_layer then
            found = x
            current_layer = k
          end if
        end if
      end if
    case GUI_CHECKBOX
      IF GUI_my = b(x).row1 AND GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col1 + 2 + LEN(get_str$(b(x).nam)) THEN
        if k > current_layer then
          found = x
          current_layer = k
        end if
      END IF
    case GUI_MENU
      if GUI_my = b(x).row1 then
        if k > current_layer then
          found = x
          current_layer = k
        end if
      end if
    case GUI_BUTTON
      IF GUI_my = b(x).row1 AND GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col1 + LEN(get_str$(b(x).nam)) + 1 THEN
        if k > current_layer then
          found = x
          current_layer = k
        end if
      END IF
    case GUI_RADIO_BUTTON
      if GUI_my = b(x).row1 AND GUI_mx >= b(x).col1 AND GUI_mx <= b(x).col1 + 2 + LEN(get_str$(b(x).nam)) THEN
        if k > current_layer then
          found = x
          current_layer = k
        end if
      end if
  END SELECT
NEXT x

if found > 0 then
  select case b(found).element_type
    case GUI_BOX
      selected_gui = found
      b(found).updated = -1
    case GUI_INPUT_BOX
      selected_gui = found
      IF GUI_my = b(found).row1 + 1 THEN
        IF GUI_mx > b(found).col1 + 1 AND GUI_mx < b(found).col2 - 1 THEN
          b(found).text_position = b(found).text_offset + GUI_mx - b(found).col1 - 1
          IF b(found).text_position > b(found).text.length THEN
            b(found).text_position = b(found).text.length
          END IF
        END IF
      END IF
      b(found).updated = -1
    case GUI_TEXT_BOX
    case GUI_LIST_BOX
      selected_gui = found
      IF GUI_my >= b(found).row1 + 1 and GUI_my <= b(found).row2 - 1 THEN
        IF GUI_mx >= b(found).col1 + 1 AND GUI_mx <= b(found).col2 - 1 THEN
          b(found).selected = GUI_my - b(found).row1 + b(found).scroll_offset_vert
        END IF
      END IF
      check_scroll = -1
      b(found).updated = -1
    case GUI_DROP_DOWN
      if selected_gui = found and GUI_my = b(found).row1 then
        b(found).drop_flag = not b(found).drop_flag
      end if
      if b(found).drop_flag then
        IF GUI_my >= b(found).row1 + 1 and GUI_my <= b(found).row2 - 1 THEN
          IF GUI_mx >= b(found).col1 + 1 AND GUI_mx <= b(found).col2 - 1 THEN
            s = GUI_my - b(found).row1 + b(found).scroll_offset_vert
            if s = b(found).selected then b(found).drop_flag = 0 else b(found).selected = s
          END IF
        END IF
        check_scroll = -1
      end if
      selected_gui = found
      b(found).updated = -1
    case GUI_CHECKBOX
      if GUI_mx = b(found).col1 + 1 then b(found).checked = not b(found).checked
      selected_gui = found
      b(found).updated = -1
    case GUI_MENU
      selected_gui = found
      b(found).updated = -1
    case GUI_BUTTON
      b(found).pressed = -1
      selected_gui = found
      b(found).updated = -1
    CASE GUI_RADIO_BUTTON
      if GUI_mx = b(found).col1 + 1 then
        b(found).checked = not b(found).checked
        FOR x = 1 to boxnum
          if x <> found then
            if b(x).element_type = GUI_RADIO_BUTTON then
              if b(x).group = b(found).group then
                b(x).checked = 0
              end if
            end if
          end if
        NEXT x
      end if
      selected_gui = found
      b(found).updated = -1
  END SELECT
  if check_scroll then
    if b(found).scroll AND 2 then
      if GUI_my = b(found).row2 then 
        if GUI_mx = b(found).col1 + 1 then
          if b(found).scroll_offset_hors > 0 then
            b(found).scroll_offset_hors = b(found).scroll_offset_hors - 1
            calc_flag = -1
          end if
        elseif GUI_mx = b(found).col2 - 1 then
          if b(found).scroll_offset_hors < (b(found).scroll_max_hors - (b(found).col2 - b(found).col1 - 1)) then
            b(found).scroll_offset_hors = b(found).scroll_offset_hors + 1
            calc_flag = -1
          end if
        end if
      end if
    end if
    if b(found).scroll AND 1 then
      if GUI_mx = b(found).col2 then
        if GUI_my = b(found).row1 + 1 then
          if b(found).scroll_offset_vert > 0 then
            b(found).scroll_offset_vert = b(found).scroll_offset_vert - 1
            calc_flag = -1
          end if
        elseif GUI_my = b(found).row2 - 1 then
          if b(found).scroll_offset_vert < (b(found).length - (b(found).row2 - b(found).row1 - 1)) then
            b(found).scroll_offset_vert = b(found).scroll_offset_vert + 1
            calc_flag = -1
          end if
        end if
      end if
    end if
  end if
  if calc_flag then GUI_calc_scroll b(found).row1, b(found).col1, b(found).row2, b(found).col2, b(found)
end if

END SUB

SUB GUI_print_menu_no_hilight (a$) 'Prints a$ without the '#' and no hilighting

PRINT MID$(a$, 1, INSTR(a$, "#") - 1);
PRINT MID$(a$, INSTR(a$, "#") + 1);
END SUB

SUB GUI_print_menu (a$, s) 'Prints a$ with the character after '#' hilighted in bright white
PRINT MID$(a$, 1, INSTR(a$, "#") - 1);
COLOR menu_char_c
PRINT MID$(a$, INSTR(a$, "#") + 1, 1);
COLOR s
PRINT MID$(a$, INSTR(a$, "#") + 2);
END SUB

FUNCTION GUI_menu_len (a$) 'Length of menu item a$.
'Just takes one away from the length if the string has a '#'`
IF INSTR(a$, "#") THEN
  menu_len = LEN(a$) - 1
ELSE
  menu_len = LEN(a$)
END IF
END FUNCTION

FUNCTION GUI_menu_char$ (a$) 'Get's the hilighted character
menu_char$ = MID$(a$, INSTR(a$, "#") + 1, 1)
END FUNCTION

SUB GUI_menu_attach ()

END SUB

SUB GUI_add_character (b AS GUI_element_type, ch$)
t$ = get_str$(b.text)
t$ = MID$(t$, 1, b.text_position) + ch$ + MID$(t$, b.text_position + 1)
'print "T="; t$;
'_DISPLAY
'sleep
put_str b.text, t$
b.text_position = b.text_position + 1
IF b.text_position > b.text_offset + (b.col2 - b.col1 - 2) THEN
  b.text_offset = b.text_offset + 1
END IF
END SUB

SUB GUI_del_character (b AS GUI_element_type)
t$ = get_str$(b.text)
IF LEN(t$) > 0 AND b.text_position > 0 THEN
  t$ = MID$(t$, 1, b.text_position - 1) + MID$(t$, b.text_position + 1)
  put_str b.text, t$
  b.text_position = b.text_position - 1
  IF b.text_position < b.text_offset THEN
    b.text_offset = b.text_offset - 1
  END IF
END IF
END SUB

SUB GUI_free_element_array (b() as GUI_element_type)
for x = 1 to ubound(b)
  GUI_free_element b(x)
next x
END SUB

SUB GUI_free_element (b as GUI_element_type)
free_string b.nam
free_string b.text
free_array b.lines
END SUB
