'FTP Client
'Copyright Matt Kilgore -- 2011/2013

'This program is free software, without any warranty of any kind.
'You are free to edit, copy, modify, and redistribute it under the terms
'of the Do What You Want Public License, Version 1, as published by Matt Kilgore
'See file COPYING that should have been included with this source.

SUB GUI_init()
GUI_debug_output "GUI being Initalized"

GUI_DRAG_SELECTION_DELAY = .05
GUI_DOUBLE_CLICK_DELAY = .33
GUI_KEYPRESS_DELAY = .7
GUI_KEYPRESS_REPEAT_DELAY = .1

GUI_HAND = GUI_HAND_RIGHT

GUI_debug_output "Setting default colors..."
GUI_DEFAULT_COLOR_BOX.mcolor.fr = 7
GUI_DEFAULT_COLOR_BOX.mcolor.bk = 1
GUI_DEFAULT_COLOR_BOX.selcolor.fr = 1
GUI_DEFAULT_COLOR_BOX.selcolor.bk = 7
GUI_DEFAULT_COLOR_BUTTON.mcolor.fr = 7
GUI_DEFAULT_COLOR_BUTTON.mcolor.bk = 1
GUI_DEFAULT_COLOR_BUTTON.selcolor.fr = 15
GUI_DEFAULT_COLOR_BUTTON.selcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.mcolor.fr = 7
GUI_DEFAULT_COLOR_DROP.mcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.selcolor.fr = 15
GUI_DEFAULT_COLOR_DROP.selcolor.bk = 1
GUI_DEFAULT_COLOR_DROP.scroll_color.fr = 0
GUI_DEFAULT_COLOR_DROP.scroll_color.bk = 7
GUI_DEFAULT_COLOR_CHECKBOX.mcolor.fr = 7
GUI_DEFAULT_COLOR_CHECKBOX.mcolor.bk = 1
GUI_DEFAULT_COLOR_CHECKBOX.selcolor.fr = 15
GUI_DEFAULT_COLOR_CHECKBOX.selcolor.bk = 1
GUI_DEFAULT_COLOR_INPUT.mcolor.fr = 7
GUI_DEFAULT_COLOR_INPUT.mcolor.bk = 1
GUI_DEFAULT_COLOR_INPUT.selcolor.fr = 1
GUI_DEFAULT_COLOR_INPUT.selcolor.bk = 7
GUI_DEFAULT_COLOR_LIST.mcolor.fr = 7
GUI_DEFAULT_COLOR_LIST.mcolor.bk = 1
GUI_DEFAULT_COLOR_LIST.selcolor.fr = 15
GUI_DEFAULT_COLOR_LIST.selcolor.bk = 1
GUI_DEFAULT_COLOR_LIST.scroll_color.fr = 0
GUI_DEFAULT_COLOR_LIST.scroll_color.bk = 7
GUI_DEFAULT_COLOR_MENU.mcolor.fr = 0
GUI_DEFAULT_COLOR_MENU.mcolor.bk = 7
GUI_DEFAULT_COLOR_MENU.selcolor.fr = 7
GUI_DEFAULT_COLOR_MENU.selcolor.bk = 0
GUI_DEFAULT_COLOR_MENU.scroll_color.fr = 15
GUI_DEFAULT_COLOR_MENU.scroll_color.bk = 7
GUI_DEFAULT_COLOR_TEXT.mcolor.fr = 7
GUI_DEFAULT_COLOR_TEXT.mcolor.bk = 1
GUI_DEFAULT_COLOR_TEXT.selcolor.fr = 7
GUI_DEFAULT_COLOR_TEXT.selcolor.bk = 1
GUI_DEFAULT_COLOR_TEXT.scroll_color.fr = 0
GUI_DEFAULT_COLOR_TEXT.scroll_color.bk = 7
GUI_DEFAULT_COLOR_RADIO.mcolor.fr = 7
GUI_DEFAULT_COLOR_RADIO.mcolor.bk = 1
GUI_DEFAULT_COLOR_RADIO.selcolor.fr = 15
GUI_DEFAULT_COLOR_RADIO.selcolor.bk = 1
GUI_DEFAULT_COLOR_LABEL.mcolor.fr = 7
GUI_DEFAULT_COLOR_LABEL.mcolor.bk = 1

GUI_DEFAULT_DIALOG_COLOR_BOX.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_BOX.mcolor.bk =7
GUI_DEFAULT_DIALOG_COLOR_BOX.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_BOX.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_BUTTON.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_BUTTON.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_BUTTON.selcolor.fr = 15
GUI_DEFAULT_DIALOG_COLOR_BUTTON.selcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_DROP.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_DROP.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_DROP.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_DROP.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_DROP.scroll_color.fr = 0
GUI_DEFAULT_DIALOG_COLOR_DROP.scroll_color.bk = 7
GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.selcolor.fr = 15
GUI_DEFAULT_DIALOG_COLOR_CHECKBOX.selcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_INPUT.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_INPUT.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_INPUT.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_INPUT.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_LIST.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_LIST.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_LIST.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_LIST.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_LIST.scroll_color.fr = 0
GUI_DEFAULT_DIALOG_COLOR_LIST.scroll_color.bk = 7
GUI_DEFAULT_DIALOG_COLOR_MENU.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_MENU.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_MENU.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_MENU.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_MENU.scroll_color.fr = 15
GUI_DEFAULT_DIALOG_COLOR_MENU.scroll_color.bk = 7
GUI_DEFAULT_DIALOG_COLOR_TEXT.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_TEXT.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_TEXT.selcolor.fr = 7
GUI_DEFAULT_DIALOG_COLOR_TEXT.selcolor.bk = 0
GUI_DEFAULT_DIALOG_COLOR_TEXT.scroll_color.fr = 0
GUI_DEFAULT_DIALOG_COLOR_TEXT.scroll_color.bk = 7
GUI_DEFAULT_DIALOG_COLOR_RADIO.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_RADIO.mcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_RADIO.selcolor.fr = 15
GUI_DEFAULT_DIALOG_COLOR_RADIO.selcolor.bk = 7
GUI_DEFAULT_DIALOG_COLOR_LABEL.mcolor.fr = 0
GUI_DEFAULT_DIALOG_COLOR_LABEL.mcolor.bk = 7
END SUB

FUNCTION GUI_update_screen (gui() AS GUI_element_type, gui_num AS INTEGER, sel AS INTEGER)
FOR x = 1 to gui_num
  if gui(x).element_type = GUI_DROP_DOWN and x <> sel and (gui(x).flags AND GUI_FLAG_DROP_FLAG) then
    gui(x).flags = gui(x).flags AND NOT GUI_FLAG_DROP_FLAG
    GUI_update_screen = -1
  end if
  if gui(x).flags AND GUI_FLAG_UPDATED then
    GUI_update_screen = -1
    gui(x).flags = gui(x).flags AND NOT GUI_FLAG_UPDATED
    GUI_debug_output "Element " + str$(x) + " was updated"
  end if
NEXT x
END FUNCTION

'Inits an element
'While it doesn't do much now besides set some default colors and the name, it's highly likely it may do more in the future
'It should be considered mandintory to use this SUB on all GUI items
'  You should set the element_type before calling this SUB
'  You should also set the GUI_FLAG_DIALOG flag if you intend to use it
SUB GUI_init_element (g as GUI_element_type, nam$)
GUI_debug_output "Initalizing element " + nam$
MEM_put_str g.nam, nam$
SELECT CASE g.element_type
  case GUI_BOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_BOX
    else
      g.c = GUI_DEFAULT_COLOR_BOX
    end if
  CASE GUI_BUTTON
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_BUTTON
    else
      g.c = GUI_DEFAULT_COLOR_BUTTON
    end if
  CASE GUI_DROP_DOWN
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_DROP
    else
      g.c = GUI_DEFAULT_COLOR_DROP
    end if
  CASE GUI_CHECKBOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_CHECKBOX
    else
      g.c = GUI_DEFAULT_COLOR_CHECKBOX
    end if
  CASE GUI_INPUT_BOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_INPUT
    else
      g.c = GUI_DEFAULT_COLOR_INPUT
    end if
  CASE GUI_LIST_BOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_LIST
    else
      g.c = GUI_DEFAULT_COLOR_LIST
    end if
  CASE GUI_MENU
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_MENU
    else
      g.c = GUI_DEFAULT_COLOR_MENU
    end if
    g.flags = g.flags OR GUI_FLAG_SKIP
  CASE GUI_TEXT_BOX
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_TEXT
    else
      g.c = GUI_DEFAULT_COLOR_TEXT
    end if
  CASE GUI_RADIO_BUTTON
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_RADIO
    else
      g.c = GUI_DEFAULT_COLOR_RADIO
    end if
  CASE GUI_LABEL
    if g.flags AND GUI_FLAG_DIALOG then
      g.c = GUI_DEFAULT_DIALOG_COLOR_LABEL
    else
      g.c = GUI_DEFAULT_COLOR_LABEL
    end if
    g.flags = g.flags OR GUI_FLAG_SKIP
END SELECT
g.flags = g.flags OR GUI_FLAG_UPDATED
END SUB

FUNCTION GUI_get_layer (b as GUI_element_type)
SELECT CASE b.element_type
  CASE GUI_BOX
    GUI_get_layer = GUI_box_get_layer(b)
  CASE GUI_INPUT_BOX
    GUI_get_layer = GUI_input_box_get_layer(b)
  CASE GUI_LIST_BOX
    GUI_get_layer = GUI_list_box_get_layer(b)
  CASE GUI_TEXT_BOX
    GUI_get_layer = GUI_text_box_get_layer(b)
  CASE GUI_DROP_DOWN
    GUI_get_layer = GUI_drop_down_get_layer(b)
  CASE GUI_MENU
    GUI_get_layer = GUI_menu_get_layer(b)
  CASE GUI_CHECKBOX
    GUI_get_layer = GUI_checkbox_get_layer(b)
  CASE GUI_BUTTON
    GUI_get_layer = GUI_button_get_layer(b)
  CASE GUI_RADIO_BUTTON
    GUI_get_layer = GUI_radio_button_get_layer(b)
  CASE GUI_LABEL
    GUI_get_layer = GUI_label_get_layer(b)
END SELECT
END FUNCTION

'Output's debug info to the CONSOLE.
'It's controlable via the GUI_DEBUG const in gui_lib.bi
SUB GUI_debug_output (s$)
IF GUI_DEBUG then
  d& = _DEST
  _DEST _CONSOLE
  PRINT s$
  _DEST d&
end if
END SUB

'###############################################################################
'###############################################################################
'#---------------------------DRAWING FUNCTIONS---------------------------------#
'###############################################################################
'###############################################################################

'Draws an array of elements, does the following things:
'  respects layering
'  Call's _DISPLAY at start and _AUTODISPLAY at the end
'  Locates the cursor to a proper spot (And stores the location)
SUB GUI_draw_element_array (b() as GUI_element_type, gui_num, selected_gui)
GUI_debug_output "Screen Update."
_DISPLAY
drawn_count = 0
FOR cur_layer = -128 to 128
  for x = 1 to gui_num
    if GUI_get_layer(b(x)) = cur_layer then
      GUI_draw_element b(x), selected_gui = x
      drawn_count = drawn_count + 1
    end if
    if drawn_count = gui_num then exit FOR
  next x
  if draw_count = gui_num then exit FOR
next cur_layer
if b(selected_gui).cur_row > 0 then
  locate b(selected_gui).cur_row, b(selected_gui).cur_col, 1
  GUI_cur_row = b(selected_gui).cur_row
  GUI_cur_col = b(selected_gui).cur_col
else
  locate ,,0
  GUI_cur_row = 0
END IF
_AUTODISPLAY
END SUB

'sel indiciates whether that box is a selected GUI element
'also -- as can be seen this is really just a wrapper around the real drawing SUB's
'SUB's are split up to simplify the process
SUB GUI_draw_element (b AS GUI_element_type, sel) 'Draws box b
'Draws a box
IF b.element_type = GUI_BOX THEN 'Plain box
  if b.flags AND GUI_FLAG_HIDE then
    color b.c.mcolor.fr, b.c.mcolor.bk
    for x = b.row1 to b.row2
      locate x, b.col1
      print space$(b.col2 - b.col1 + 1);
    next x
  else
    GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
  end if
ELSEIF b.element_type = GUI_INPUT_BOX THEN 'Input box
  GUI_draw_input_box b, sel

ELSEIF b.element_type = GUI_TEXT_BOX THEN 'TextBox
  GUI_draw_text_box b, sel

ELSEIF b.element_type = GUI_LIST_BOX THEN 'list box
  GUI_draw_list_box b, sel

ELSEIF b.element_type = GUI_DROP_DOWN THEN 'Dropdown
  GUI_draw_dropdown b, sel

ELSEIF b.element_type = GUI_CHECKBOX THEN 'Checkbox
  GUI_draw_checkbox b, sel

ELSEIF b.element_type = GUI_MENU THEN 'Menu
  GUI_draw_menu b, sel

ELSEIF b.element_type = GUI_BUTTON THEN 'Button
  GUI_draw_button b, sel

ELSEIF b.element_type = GUI_RADIO_BUTTON THEN 'Radio button
  GUI_draw_radio_button b, sel

ELSEIF b.element_type = GUI_LABEL THEN 'Label
  GUI_draw_label b, sel

END IF
END SUB

SUB GUI_draw_checkbox (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.c.selcolor.fr, b.c.selcolor.bk ELSE COLOR b.c.mcolor.fr MOD 8, b.c.mcolor.bk
PRINT "[";
IF b.flags AND GUI_FLAG_CHECKED THEN PRINT chr$(251); ELSE PRINT " ";
PRINT "]";
COLOR b.c.mcolor.fr, b.c.mcolor.bk
PRINT MEM_get_str$(b.nam);
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_radio_button (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.c.selcolor.fr, b.c.selcolor.bk ELSE COLOR b.c.mcolor.fr MOD 8, b.c.mcolor.bk
PRINT "(";
IF b.flags AND GUI_FLAG_CHECKED THEN PRINT chr$(254); ELSE PRINT " ";
PRINT ")";
COLOR b.c.mcolor.fr, b.c.mcolor.bk
PRINT MEM_get_str$(b.nam);
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_button (b as GUI_element_type, sel)
LOCATE b.row1, b.col1
IF sel THEN COLOR b.c.selcolor.fr, b.c.selcolor.bk ELSE COLOR b.c.mcolor.fr MOD 8, b.c.mcolor.bk
PRINT "<";
'IF sel THEN COLOR b.selcol, b.c2 ELSE COLOR b.c1 MOD 8, b.c2
COLOR b.c.mcolor.fr, b.c.mcolor.bk
PRINT MEM_get_str$(b.nam);
IF sel THEN COLOR b.c.selcolor.fr, b.c.selcolor.bk ELSE COLOR b.c.mcolor.fr MOD 8, b.c.mcolor.bk
PRINT ">";
b.cur_row = b.row1
b.cur_col = b.col1 + 1
END SUB

SUB GUI_draw_input_box (b as GUI_element_type, sel)

GUI_draw_Box b.row1, b.col1, b.row1 + 2, b.col2, b
s$ = mid$(MEM_get_str$(b.text), b.scroll_offset_hors + 1, b.col2 - b.col1 - 1)
IF (b.flags AND GUI_FLAG_HIDE) THEN s$ = STRING$(LEN(s$), "*")
col1 = b.text_sel_col1
col2 = b.text_sel_col2
if col2 < col1 then
  swap col1, col2
end if
if col1 = col2 OR sel = 0 then
  color b.c.mcolor.fr, b.c.mcolor.bk
  LOCATE b.row1 + 1, b.col1 + 1
  's$ = MID$(MEM_get_str$(b.text), b.scroll_offset_hors + 1, b.col2 - b.col1 - 1)
  print s$;
else
  locate b.row1 + 1, b.col1 + 1
  if col1 <= b.scroll_offset_hors then
    'Selected text goes off the left of the box
    color b.c.selcolor.fr, b.c.selcolor.bk
    print mid$(s$, 1, col2 - b.scroll_offset_hors);
    color b.c.mcolor.fr, b.c.mcolor.bk
    print mid$(s$, col2 - b.scroll_offset_hors + 1);
  elseif col1 > b.scroll_offset_hors and col2 < b.scroll_offset_hors + (b.col2 - b.col1) then
    'Selected text is completely on the screen
    color b.c.mcolor.fr, b.c.mcolor.bk
    print mid$(s$, 1, col1 - b.scroll_offset_hors);
    color b.c.selcolor.fr, b.c.selcolor.bk
    print mid$(s$, col1 - b.scroll_offset_hors + 1, col2 - col1);
    color b.c.mcolor.fr, b.c.mcolor.bk
    print mid$(s$, col2 - b.scroll_offset_hors + 1);
  else
    'Selected text goes off the left of the screen
    color b.c.mcolor.fr, b.c.mcolor.bk
    print mid$(s$, 1, col1 - b.scroll_offset_hors + 1);
    color b.c.selcolor.fr, b.c.selcolor.bk
    print mid$(s$, col1 - b.scroll_offset_hors + 1);
  end if
end if
b.cur_row = b.row1 + 1
b.cur_col = b.col1 + 1 + b.text_position - b.scroll_offset_hors
END SUB

SUB GUI_draw_dropdown (b as GUI_element_type, sel)
_CONTROLCHR OFF
LOCATE b.row1, b.col1
COLOR b.c.mcolor.fr, b.c.mcolor.bk
if b.flags AND GUI_FLAG_DROP_FLAG then
  GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
  _CONTROLCHR OFF
end if
IF (b.flags AND GUI_FLAG_DROP_FLAG) = 0 THEN PRINT "[";
IF sel THEN COLOR b.c.selcolor.fr, b.c.selcolor.bk
locate b.row1, b.col1 + 1
PRINT LEFT$(MEM_get_str_array$(b.lines, b.selected) + SPACE$(b.col2 - b.col1), b.col2 - b.col1 - 2); CHR$(31);
COLOR b.c.mcolor.fr, b.c.mcolor.bk
IF (b.flags AND GUI_FLAG_DROP_FLAG) = 0 THEN PRINT "]";
if b.flags AND GUI_FLAG_DROP_FLAG then
  s = GUI_draw_inside_text(b)
end if
_CONTROLCHR ON
if s = 0 then
  b.cur_row = 0
  b.cur_col = 0
else
  b.cur_row = s + b.row1
  b.cur_col = b.col1 + 1
end if
END SUB

SUB GUI_draw_menu (b as GUI_element_type, sel)
DIM men as GUI_menu_item_type
DIM menu_sel, menu_row1, menu_col1

if NOT sel then b.flags = (b.flags AND NOT GUI_FLAG_MENU_OPEN) AND NOT GUI_FLAG_MENU_ALT : b.selected = 0

locate b.row1, b.col1
color b.c.mcolor.fr, b.c.mcolor.bk
print space$(b.col2 - b.col1 + 1)
locate b.row1, b.col1
PRINT SPACE$(b.menu_padding);
for x = 1 to b.length
  men = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
  if x = b.length and (b.flags AND GUI_FLAG_MENU_LAST_ON_RIGHT) then
    locate , b.col2 - GUI_menu_len(MEM_get_Str$(men.nam)) - 2
  end if
  if b.selected = x and sel then
    if b.flags AND GUI_FLAG_MENU_OPEN then
      'menu_sel = x
      menu_row1 = CSRLIN + 1
      menu_col1 = POS(0) - 1
      if menu_col1 < 1 then menu_col1 = 1
    end if
    color b.c.selcolor.fr, b.c.selcolor.bk
    if (b.flags AND GUI_FLAG_MENU_ALT) = 0 then
      GUI_print_menu_no_hilight MEM_get_str$(men.nam) ', b.mcolor.fr, b.mcolor.bk, b.scroll_color.fr, b.scroll_color.bk
    else
      GUI_print_menu MEM_get_str$(men.nam), b.c.selcolor.fr, b.c.selcolor.bk, b.c.scroll_color.fr, b.c.selcolor.bk
    end if
  else
    color b.c.mcolor.fr, b.c.mcolor.bk
    if (b.flags AND GUI_FLAG_MENU_ALT) = 0 then
      GUI_print_menu_no_hilight MEM_get_str$(men.nam)
    else
      GUI_print_menu MEM_get_str$(men.nam), b.c.mcolor.fr, b.c.mcolor.bk, b.c.scroll_color.fr, b.c.mcolor.bk
    end if
  end if
next x
if b.flags AND GUI_FLAG_MENU_OPEN then
  'men = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (b.selected - 1), GUI_menu_item_type)
  GUI_draw_gui_menu b ', men, menu_row1, menu_col1
end if
b.cur_row = 0
b.cur_col = 0
END SUB

SUB GUI_draw_list_box (b as GUI_element_type, sel)
GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
s = GUI_draw_inside_text(b)
if s > 0 then
  b.cur_row = b.row1 + s
  b.cur_col = b.col1 + 1
else
  b.cur_row = 0
end if
END SUB

SUB GUI_draw_text_box (b as GUI_element_type, sel)
GUI_draw_box b.row1, b.col1, b.row2, b.col2, b
s = GUI_draw_inside_text(b)
if s > 0 then
  b.cur_row = b.row1 + s
  b.cur_col = b.col1 + 1 + b.text_position - b.scroll_offset_hors
  if b.cur_col <= b.col1 or b.cur_col >= b.col2 then
    b.cur_row = 0
  end if
else
  b.cur_row = 0
end if
END SUB

SUB GUI_draw_label (b as GUI_element_type, sel)
COLOR b.c.mcolor.fr, b.c.mcolor.bk
LOCATE b.row1, b.col1
print MEM_get_str$(b.text);
END SUB

SUB GUI_draw_gui_menu (b as GUI_element_type) ', m as GUI_menu_item_type, row1, col1)
STATIC count, m as GUI_menu_item_type
DIM men as GUI_menu_item_type
DIM men_next_menu as GUI_menu_item_type, sub_menu_row1, sub_menu_col1, sub_menu_open

GUI_debug_output "Finding Menu location..."
GUI_get_menu_location b, count + 1, row1, col1, row2, col2

if count = 0 then m = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (b.selected - 1), GUI_menu_item_type)

GUI_debug_output "Row1:" + str$(row1) + " Col1" + str$(col1) + " Row2:" + str$(row2) + " Col2:" + str$(col2)
wid = col2 - col1 - 3
IF b.flags AND GUI_FLAG_SHADOW THEN
  GUI_draw_box_shadow row1, col1, row2, col2
END IF
_CONTROLCHR OFF
color b.c.mcolor.fr, b.c.mcolor.bk
locate row1, col1
PRINT CHR$(218); STRING$(col2 - col1 - 1, 196); CHR$(191);
for x = 1 to m.sub_menu_length
  men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
  if men.sub_menu_open and men.has_sub then
    men_next_menu = men
    sub_menu_row1 = row1 + x - 1
    sub_menu_col1 = col2 + 1
    sub_menu_open = -1
  end if
next x
for x = 1 to m.sub_menu_length
  men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
  locate x + row1, col1
  color b.c.mcolor.fr, b.c.mcolor.bk
  print chr$(179);
  if MEM_get_str$(men.nam) = "-" then
    if m.selected = x then
      color b.c.selcolor.fr, b.c.selcolor.bk
    else
      color b.c.mcolor.fr, b.c.mcolor.bk
    end if
    locate , col1
    PRINT CHR$(195); STRING$(col2 - col1 - 1, 196); CHR$(180);
  else
    if m.selected = x then
      if GUI_alt_flag AND NOT sub_menu_open then
        GUI_print_menu MEM_get_str$(men.nam), b.c.selcolor.fr, b.c.selcolor.bk, b.c.scroll_color.fr, b.c.selcolor.bk
      else
        color b.c.selcolor.fr, b.c.selcolor.bk
        GUI_print_menu_no_hilight MEM_get_str$(men.nam)
      end if
    else
      if GUI_alt_flag AND NOT sub_menu_open then
        GUI_print_menu MEM_get_str$(men.nam), b.c.mcolor.fr, b.c.mcolor.bk, b.c.scroll_color.fr, b.c.mcolor.bk
      else
        GUI_print_menu_no_hilight MEM_get_str$(men.nam)
      end if
    end if
    if men.has_sub then
      PRINT SPACE$(wid - GUI_menu_len(MEM_get_str$(men.nam)) - 1); chr$(16);
    else
      PRINT SPACE$(wid - GUI_menu_len(MEM_get_Str$(men.nam)));
    end if

    color b.c.mcolor.fr, b.c.mcolor.bk
    print chr$(179);
  end if
next x
locate row2, col1
color b.c.mcolor.fr, b.c.mcolor.bk
print CHR$(192); STRING$(col2 - col1 - 1, 196); CHR$(217);
if sub_menu_open then
  m = men_next_menu
  count = count + 1
  GUI_draw_gui_menu b ', men_next_menu, sub_menu_row1, sub_menu_col1
  count = count - 1
end if
_CONTROLCHR ON
END SUB

'Draws a shadow around the location
'row1, col1, row2, col2 are not the location of the shadow, but the location of the box the shadow will be around
'The settings in this SUB draw the shadow two columns past the box on the left, and one row past the box on the bottom
SUB GUI_draw_box_shadow (row1, col1, row2, col2)
_CONTROLCHR OFF
'FOR x = row1 + 1 TO row2 + 1
'  FOR y = col1 + 2 TO col2 + 2
'    chr = SCREEN(x, y)
'    colo = SCREEN(x, y, 1)
'    LOCATE x, y
'    COLOR colo MOD 8, 0
'    PRINT CHR$(chr);
'  NEXT y
'NEXT x
FOR y = col1 + 2 TO col2 + 2
  chr = SCREEN(row2 + 1, y)
  colo = SCREEN(row2 + 1, y, 1)
  LOCATE row2 + 1, y
  COLOR colo MOD 8, 0
  PRINT CHR$(chr);
NEXT y
FOR x = row1 + 1 to row2 + 1
  FOR y = col2 + 1 to col2 + 2
    chr = SCREEN(x, y)
    colo = SCREEN(x, y, 1)
    LOCATE x, y
    color colo MOD 8, 0
    PRINT chr$(chr);
  next y
NEXT x
_CONTROLCHR ON
END SUB

SUB GUI_draw_box (row1, col1, row2, col2, b as GUI_element_type)
IF b.flags AND GUI_FLAG_SHADOW THEN
  GUI_draw_box_shadow row1, col1, row2, col2
END IF
_CONTROLCHR OFF
if (b.flags AND GUI_FLAG_SCROLL_V) and (b.scroll_loc_vert = 0) then GUI_calc_scroll row1, col1, row2, col2, b
if (b.flags AND GUI_FLAG_SCROLL_H) and (b.scroll_loc_hors = 0) then GUI_calc_scroll row1, col1, row2, col2, b
n$ = MEM_get_str$(b.nam)
COLOR b.c.mcolor.fr, b.c.mcolor.bk
LOCATE row1, col1
PRINT CHR$(218); CHR$(196); n$; STRING$(col2 - col1 - 2 - LEN(n$), 196); CHR$(191);
FOR x = row1 + 1 TO row2 - 1
  LOCATE x, col1
  COLOR b.c.mcolor.fr, b.c.mcolor.bk
  PRINT CHR$(179); SPACE$(col2 - col1 - 1);
  IF (b.flags AND GUI_FLAG_SCROLL_V) = 0 THEN
    PRINT CHR$(179);
  END IF
  IF b.flags AND GUI_FLAG_SCROLL_V THEN
    COLOR b.c.scroll_color.fr, b.c.scroll_color.bk
    SELECT CASE x
      CASE row1 + 1
        PRINT CHR$(24);
      CASE row2 - 1
        PRINT CHR$(25);
      CASE ELSE
        IF b.scroll_loc_vert = x THEN
          PRINT CHR$(219);
        ELSE
          PRINT CHR$(176);
        END IF
    END SELECT
  END IF
NEXT x
COLOR b.c.mcolor.fr MOD 8, b.c.mcolor.bk
LOCATE row2, col1
print CHR$(192);
if NOT (b.flags AND GUI_FLAG_SCROLL_H) then
  PRINT STRING$(col2 - col1 - 1, 196);
else
  color b.c.scroll_color.fr, b.c.scroll_color.bk
  PRINT chr$(27);
  print string$(b.scroll_loc_hors - b.col1 - 2, 176);
  print chr$(219);
  print string$(b.col2 - b.scroll_loc_hors - 2, 176); chr$(26);
  COLOR b.c.mcolor.fr MOD 8, b.c.mcolor.bk
end if
print CHR$(217);
_CONTROLCHR ON
END SUB

FUNCTION GUI_draw_inside_text (b as GUI_element_type)
for x = 1 to b.row2 - b.row1 - 1
  locate x + b.row1, b.col1 + 1
  if (b.selected - b.scroll_offset_vert) = (x) then
    s = x
    color b.c.selcolor.fr, b.c.selcolor.bk
  else
    color b.c.mcolor.fr, b.c.mcolor.bk
  end if
  if x + b.scroll_offset_vert <= b.length then
    k$ = mid$(MEM_get_str_array$(b.lines, x + b.scroll_offset_vert), b.scroll_offset_hors + 1, b.col2 - b.col1 - 1)
  else
    k$ = ""
  end if
  k$ = k$ + space$((b.col2 - b.col1 - 1) - len(k$))
  print k$;
next x
GUI_draw_inside_text = s
END FUNCTION

SUB GUI_print_menu_no_hilight (a$) 'Prints a$ without the '#' and no hilighting
PRINT " "; MID$(a$, 1, INSTR(a$, "#") - 1); MID$(a$, INSTR(a$, "#") + 1); " ";
END SUB

SUB GUI_print_menu (a$, c1, c2, menu_c1, menu_c2) 'Prints a$ with the character after '#' hilighted in bright white
color c1, c2
PRINT " "; MID$(a$, 1, INSTR(a$, "#") - 1);
COLOR menu_c1, menu_c2
PRINT MID$(a$, INSTR(a$, "#") + 1, 1);
COLOR c1, c2
PRINT MID$(a$, INSTR(a$, "#") + 2); " ";
END SUB

'###############################################################################
'###############################################################################
'#-----------------------MEMORY FREEING FUNCTIONS------------------------------#
'###############################################################################
'###############################################################################


'Recurses through a menu element to free all it's assosiated sub menus before freeing the actual menu
SUB GUI_free_menu(m as GUI_menu_item_type)
DIM men as GUI_menu_item_type
MEM_free_string m.nam 'First free it's strings
MEM_free_string m.key_combo
if m.has_sub then
  FOR x = 1 to m.sub_menu_length 'free any sub menus of this item
    men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
    GUI_free_menu men
  next x
  _MEMFREE m.sub_menu
end if
'... I don't think I need to free the _MEM (m.sub_menu) because it points to a fixed array
' EDIT I was wrong... I think...
END SUB

'Call to free the memory of an array of GUI elements
SUB GUI_free_element_array (b() as GUI_element_type)
for x = 1 to ubound(b)
  GUI_free_element b(x)
next x
END SUB

'Call to free the memory being used by a GUI element
SUB GUI_free_element (b as GUI_element_type)
DIM m as GUI_menu_item_type
MEM_free_string b.nam 'Free MEM_string_type's and MEM_array_Types
MEM_free_string b.text
MEM_free_array b.lines
IF b.element_type = GUI_MENU then 'If we're a menu, then we have to free our menu items
  if b.length > 0 then
    FOR x = 1 to b.length
      m = _MEMGET(b.menu, b.menu.OFFSET + len(m) * (x - 1), GUI_menu_item_type)
      GUI_free_menu m
    next x
  end if
  _MEMFREE b.menu
end if
END SUB

'###############################################################################
'###############################################################################
'#------------------------------MENU FUNCTIONS---------------------------------#
'###############################################################################
'###############################################################################

'Attaches a sub menu to a menu item
'Takes:
'  menu_item --> The menu item you want to attach a sub-menu too
'  item_num --> Number of choices in the sub menu
'  items --> _OFFSET to an array of GUI_menu_item_type, it should be of size item_num
'Call just like GUI_attach_base_menu, except with a GUI_menu_item_type in place of the GUI element
SUB GUI_attach_menu (menu_item as GUI_menu_item_type, item_num AS INTEGER, items as _OFFSET)
menu_item.sub_menu_length = item_num
menu_item.sub_menu = _MEM(items, LEN(menu_item) * item_num)
menu_item.has_sub = -1
menu_item.selected = 0
END SUB

'Attaches the base menu (Horisontal menu) to a GUI_MENU
'Takes:
'  g --> GUI element, the GUI_MENU you want to attach the menu too
'  item_num --> Number of menu items
'  items --> an _OFFSET to an array of GUI_menu_item_type, it should be of size item_num
'If you just use arrays of GUI_menu_item_type then call this using _OFFSET(array_name) for the last parameter
SUB GUI_attach_base_menu (g as GUI_element_type, item_num AS INTEGER, items as _OFFSET)
DIM m as GUI_menu_item_type
g.menu = _MEM(items, LEN(m) * item_num)
g.length = item_num
END SUB

SUB GUI_get_menu_location (b as GUI_element_type, sel, row1, col1, row2, col2)
STATIC count, m as GUI_menu_item_type
DIM men as GUI_menu_item_type, mnext as GUI_menu_item_type
if count = 0 then
  row1 = b.row1
  col1 = b.col1
  row2 = b.row1
  col2 = b.col2
else
  if count = 1 then
    row1 = b.row1
    col2 = b.col1 + b.menu_padding - 1
    for x = 1 to b.selected
      men = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
      if x = b.length AND (b.flags AND GUI_FLAG_MENU_LAST_ON_RIGHT) then
        col1 = b.col2 - GUI_menu_len(MEM_get_str$(men.nam)) - 2
      else
        col1 = col2
      end if
      col2 = col1 + 2 + GUI_menu_len(MEM_get_str$(men.nam))
    next x
    row2 = row1
    m = men
  else
    col1 = col2 + 1
  end if

  wid = 0
  if col1 <=0 then
    col1 = 1
  end if
  if row1 <= 0 then
    row1 = 1
  end if
  row1 = row1 + 1
  row2 = row1 + m.sub_menu_length + 1
  for x = 1 to m.sub_menu_length
    men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
    GUI_debug_output "Menu item: " + MEM_get_str$(men.nam)
    l = GUI_menu_len(MEM_get_str$(men.nam))
    if l > wid then
      wid = l
    end if
    if men.has_sub then
      GUI_debug_output "In Has sub!!!"
      has_sub = -1
      if x = m.selected and men.sub_menu_open then mnext = men: GUI_debug_output "Sub menu open"
    end if
  next x
  if has_sub then wid = wid + 2
  col2 = col1 + wid + 3
  row2 = row1 + m.sub_menu_length + 1
  if b.flags AND GUI_FLAG_SHADOW then c = col2 + 2 else c = col2
  if c  > _WIDTH(0) then
    col1 = col1 - (c - _WIDTH(0))
    col2 = col1 + wid + 3
  end if
  if row2 > _HEIGHT(0) then
    row1 = row1 - m.sub_menu_length - 2
    if b.flags AND GUI_FLAG_SHADOW then row1 = row1 - 1
    row2 = row1 + m.sub_menu_length + 2
  end if
end if
count = count + 1
if count <= sel then
  m = mnext
  GUI_get_menu_location b, sel, row1, col1, row2, col2
end if
count = count - 1
END SUB

FUNCTION GUI_menu_len (a$) 'Length of menu item a$.
'Just takes one away from the length if the string has a '#'`
IF INSTR(a$, "#") THEN
  GUI_menu_len = LEN(a$) - 1
ELSE
  GUI_menu_len = LEN(a$)
END IF
END FUNCTION

FUNCTION GUI_menu_char$ (a$) 'Get's the hilighted character
GUI_menu_char$ = MID$(a$, INSTR(a$, "#") + 1, 1)
END FUNCTION

'send it the X and Y of the mouse as well an GUI_MENU element
'If it returned -1 then the debth of the menu it clicked on will be in debth
'And element will be 'selection'
FUNCTION GUI_menu_clicked_on (b as GUI_element_type, cx, cy, debth, selection)
STATIC count, m AS GUI_menu_item_type
DIM men as GUI_menu_item_type, mtmp as GUI_menu_item_type
DIM mem_sav AS GUI_menu_item_type
GUI_get_menu_location b, count, row1, col1, row2, col2

if count = 0 then
  if b.selected > 0 and (b.flags OR GUI_FLAG_MENU_OPEN) then
    m = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (b.selected - 1), GUI_menu_item_type)
    h_sub_menu = -1
  end if
else
  if m.has_sub and m.sub_menu_open then
    m = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(m) * (m.selected - 1), GUI_menu_item_type)
    h_sub_menu = -1
  end if
end if

mem_sav = m
count = count + 1
if h_sub_menu then 
  clicked = GUI_menu_clicked_on(b, cx, cy, debth, selection)
end if
count = count - 1
m = mem_sav
if not clicked then
  if cx >= col1 and cx <= col2 and cy >= row1 and cy <= row2 then
    GUI_debug_output "Click!"
    clicked = -1
    debth = count 
    selection = 0
    if count = 0 then
      c = col1 + b.menu_padding
      for x = 1 to b.length
        men = _MEMGET(b.menu, b.menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
        if x = b.length AND (b.flags AND GUI_FLAG_MENU_LAST_ON_RIGHT) then
          c = b.col2 - GUI_menu_len(MEM_get_str$(men.nam)) - 2
        end if
        if cx >= c and cx <= c + 2 + GUI_menu_len(MEM_get_str$(men.nam)) then
          selection = x
        end if
        c = c + 2 + GUI_menu_len(MEM_get_str$(men.nam))
      next x
      row2 = row1
    else
      GUI_debug_output "About to check mem"
      s = cy - row1
      'if s > 0 and s <= row2 - row1 then
      '  mtmp = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(mtmp) * (s - 1), GUI_menu_item_type)
      '  if MEM_get_str$(mtmp.nam) <> "-" then
          selection = s
      '  else
      '    clicked = 0
      '  end if
      'end if
      GUI_debug_output "Done!"
    end if
  end if
end if
GUI_debug_output "Selection: " + str$(selection)
if clicked then GUI_menu_clicked_on = -1
END FUNCTION

'recursivly close sub menus by setting their selected value to zero
SUB GUI_close_sub_menu (m as GUI_menu_item_type)
DIM men as GUI_menu_item_type
if m.has_sub then
  FOR x = 1 to m.sub_menu_length
    men = _MEMGET(m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
    men.sub_menu_open = 0
    _MEMPUT m.sub_menu, m.sub_menu.OFFSET + len(men) * (x - 1), men
  next x
end if
END SUB

'm = 1 -> up
'm = 2 -> right
'm = 3 -> down
'm = 4 -> left
'm = 5 -> enter
SUB GUI_menu_movement(m, b as GUI_element_type)
'The end of the menu chain is where we are located
M_UP = 1
M_RIGHT = 2
M_DOWN = 3
M_LEFT = 4
M_ENTER = 5

DIM tempm AS GUI_menu_item_type, men AS GUI_menu_item_type, mtmp as GUI_menu_item_type
DIM memtmp as _MEM, offset as _OFFSET

if (b.flags AND GUI_FLAG_MENU_OPEN) = 0 OR (b.flags AND GUI_FLAG_MENU_ALT) then
  if (m = M_DOWN OR m = M_ENTER) and b.selected > 0 then
    b.flags = b.flags OR GUI_FLAG_MENU_OPEN OR GUI_FLAG_UPDATED
    tempm = _MEMGET(b.menu, b.menu.OFFSET + len(tempm) * (b.selected - 1), GUI_menu_item_type)
    tempm.selected = 1
    _MEMPUT b.menu, b.menu.OFFSET + len(tempm) * (b.selected - 1), tempm
    GUI_close_sub_menu tempm
  elseif m = M_LEFT then
    b.selected = b.selected - 1
    if b.selected = 0 then b.selected = b.length
    b.flags = b.flags OR GUI_FLAG_UPDATED
  elseif m = M_RIGHT then
    b.selected = (b.selected mod b.length) + 1
    b.flags = b.flags OR GUI_FLAG_UPDATED
  end if
elseif b.flags AND GUI_FLAG_MENU_OPEN then
  memtmp = b.menu
  offset = len(mtmp) * (b.selected - 1)
  mtmp = _MEMGET(b.menu, b.menu.OFFSET + len(mtmp) * (b.selected - 1), GUI_menu_item_type)
  d = 0
  do
    men = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(men) * (mtmp.selected - 1), GUI_menu_item_type)
    if men.sub_menu_open then
      d = d + 1
      memtmp = mtmp.sub_menu
      offset = len(mtmp) * (mtmp.selected - 1)
      mtmp = men
    end if
  loop until not men.sub_menu_open
  if m = M_DOWN then
    do  
      mtmp.selected = (mtmp.selected mod mtmp.sub_menu_length) + 1
      tempm = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(tempm) * (mtmp.selected - 1), GUI_menu_item_type)
    loop until MEM_get_str$(tempm.nam) <> "-"
  elseif m = M_UP then
    do
      mtmp.selected = mtmp.selected - 1
      if mtmp.selected = 0 then mtmp.selected = mtmp.sub_menu_length
      tempm = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(tempm) * (mtmp.selected - 1), GUI_menu_item_type)
    loop until MEM_get_str$(tempm.nam) <> "-"
  elseif m = M_RIGHT then
    tempm = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(mtmp) * (mtmp.selected - 1), GUI_menu_item_type)
    GUI_debug_output "Menu item: " + MEM_get_str$(mtmp.nam)
    GUI_debug_output "Menu item2: " + MEM_Get_str$(tempm.nam)
    if tempm.has_sub then
      GUI_debug_output "Sub menu found!"
      tempm.sub_menu_open = -1
      tempm.selected = 1
      GUI_close_sub_menu tempm
      _MEMPUT mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(mtmp) * (mtmp.selected - 1), tempm
    else
      b.selected = (b.selected mod b.length) + 1
      tempm = _MEMGET(b.menu, b.menu.OFFSET + len(tempm) * (b.selected - 1), GUI_menu_item_type)
      tempm.selected = 1
      if tempm.has_sub then mtmp.sub_menu_open = -1
      _MEMPUT b.menu, b.menu.OFFSET + len(tempm) * (b.selected - 1), tempm
      GUI_close_sub_menu tempm
    end if
  elseif m = M_LEFT then
    if d <> 0 then
      mtmp.sub_menu_open = 0
    else
      b.selected = b.selected - 1
      if b.selected = 0 then b.selected = b.length
      mtmp = _MEMGET(b.menu, b.menu.OFFSET + len(mtmp) * (b.selected - 1), GUI_menu_item_type)
      mtmp.selected = 1
      GUI_close_sub_menu mtmp
      offset = len(mtmp) * (b.selected - 1)
    end if
  elseif m = M_ENTER then
    if not men.has_sub then
      b.menu_choice = men.ident
      b.selected = 0
      b.flags = (b.flags OR GUI_FLAG_MENU_CHOSEN OR GUI_FLAG_UPDATED) AND NOT GUI_FLAG_MENU_OPEN
    else
      'tempm = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(mtmp) * (mtmp.selected - 1), GUI_menu_item_type)
      men.sub_menu_open = -1
      men.selected = 1
      GUI_close_sub_menu men
      _MEMPUT mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(mtmp) * (mtmp.selected - 1), men
    end if
  end if
  _MEMPUT memtmp, memtmp.OFFSET + offset, mtmp
  b.flags = b.flags OR GUI_FLAG_UPDATED
end if

END SUB

'###############################################################################
'###############################################################################
'#-----------------------------SCROLL FUNCTIONS--------------------------------#
'###############################################################################
'###############################################################################

SUB GUI_fix_scroll (gui AS GUI_element_type)
if gui.selected - 1 < gui.scroll_offset_vert then
  gui.scroll_offset_vert = gui.selected - 1
elseif gui.selected > gui.scroll_offset_vert + (gui.row2 - gui.row1 - 1) then
  gui.scroll_offset_vert = gui.selected  - (gui.row2 - gui.row1 - 1)
end if
if gui.scroll_offset_vert < 0 then gui.scroll_offset_vert = 0
if gui.scroll_offset_vert + (gui.row2 - gui.row1 - 1) > gui.length then
  gui.scroll_offset_vert = gui.length - (gui.row2 - gui.row1 - 1)
end if
END SUB

'This will recalculate scroll bar locations
SUB GUI_calc_scroll (row1, col1, row2, col2, b as GUI_element_type)
if b.scroll_offset_vert + (row2 - row1 - 1) > b.length and b.length > row2 - row1 - 1 then
  b.scroll_offset_vert = b.length - (row2 - row1 - 1)
elseif b.length < row2 - row1 - 1 then
  b.scroll_offset_vert = 0
end if
IF b.flags AND GUI_FLAG_SCROLL_V THEN
  if (b.length - (row2 - row1 - 1)) > 0 then
    b.scroll_loc_vert = (((b.scroll_offset_vert) / (b.length - (row2 - row1 - 1))) * (row2 - row1 - 4) + row1 + 2)
  else
    b.scroll_loc_vert = row1
  end if
end if
if b.flags AND GUI_FLAG_SCROLL_H then
  if (b.scroll_max_hors - (col2 - col1 - 1)) > 0 then
    b.scroll_loc_hors = (((b.scroll_offset_hors) / (b.scroll_max_hors - (col2 - col1 - 1))) * (col2 - col1 - 4) + col1 + 2)
  else
    b.scroll_loc_hors = col1
  end if
end if
END SUB

SUB GUI_calc_vert_offset (g as GUI_element_type)
l = g.scroll_loc_vert - g.row1 - 2
g.scroll_offset_vert = ( l / (g.row2 - g.row1 - 4)) * (g.length - (g.row2 - g.row1 - 1))
END SUB

SUB GUI_calc_hors_offset (g as GUI_element_type)
l = g.scroll_loc_hors - g.col1 - 2
g.scroll_offset_hors = ( l / (g.col2 - g.col1 - 4)) * (g.scroll_max_hors - (g.col2 - g.col1 - 1))
END SUB

SUB GUI_adjust_scroll (e as GUI_element_type, r, c)
if e.flags AND GUI_FLAG_SCROLL_H then
  if r = e.row2 then
    if c = e.col1 + 1 then
      if e.scroll_offset_hors > 0 then
        e.scroll_offset_hors = e.scroll_offset_hors - 1
        calc_flag = -1
      end if
    elseif c = e.col2 - 1 then
      if e.scroll_offset_hors < (e.scroll_max_hors - (e.col2 - e.col1 - 1)) then
        e.scroll_offset_hors = e.scroll_offset_hors + 1
        calc_flag = -1
      end if
    'elseif c = e.scroll_loc_hors then
    '  e.flags = e.flags OR GUI_FLAG_SCROLL_IS_HELD_H
    '  flag = -1
    end if
  end if
end if
if e.flags AND GUI_FLAG_SCROLL_V then
  if c = e.col2 then
    if r = e.row1 + 1 then
      if e.scroll_offset_vert > 0 then
        e.scroll_offset_vert = e.scroll_offset_vert - 1
        calc_flag = -1
      end if
    elseif r = e.row2 - 1 then
      if e.scroll_offset_vert < (e.length - (e.row2 - e.row1 - 1)) then
        e.scroll_offset_vert = e.scroll_offset_vert + 1
        calc_flag = -1
      end if
    'elseif r = e.scroll_loc_vert then
    '  e.flags = e.flags OR GUI_FLAG_SCROLL_IS_HELD_V
    '  flag = -1
    end if
  end if
end if
if calc_flag then GUI_calc_scroll e.row1, e.col1, e.row2, e.col2, e
END SUB

FUNCTION GUI_process_mouse_scroll_bar (e as GUI_element_type, r, c)
if e.flags AND GUI_FLAG_SCROLL_IS_HELD_H then 'hors
  if e.scroll_loc_hors <> c then
    flag = -1
    e.scroll_loc_hors = c
    if e.scroll_loc_hors - e.col1 - 2 < 0 then
      e.scroll_loc_hors = e.col1 + 2
    end if
    if e.scroll_loc_hors > e.col2 - 2 then
      e.scroll_loc_hors = e.col2 - 2
    end if
    GUI_calc_hors_offset e
    e.flags = e.flags OR GUI_FLAG_UPDATED
  end if
end if
if e.flags AND GUI_FLAG_SCROLL_IS_HELD_V then 'vert
  if e.scroll_loc_vert <> r then
    flag = -1
    e.scroll_loc_vert = r
    if e.scroll_loc_vert - e.row1 - 2 < 0 then
      e.scroll_loc_vert = e.row1 + 2
    end if
    if e.scroll_loc_vert > e.row2 - 2 then
      e.scroll_loc_vert = e.row2 - 2
    end if
    GUI_calc_vert_offset e
    e.flags = e.flags OR GUI_FLAG_UPDATED
  end if
end if
GUI_process_mouse_scroll_bar = flag
END FUNCTION

SUB GUI_hold_scroll_bar (e as GUI_element_type, r, c)
e.flags = ((e.flags) AND NOT GUI_FLAG_SCROLL_IS_HELD_H) AND NOT GUI_FLAG_SCROLL_IS_HELD_V
if e.flags AND GUI_FLAG_SCROLL_H then
  if r = e.row2 then
    if c = e.scroll_loc_hors then
      e.flags = e.flags OR GUI_FLAG_SCROLL_IS_HELD_H
    end if
  end if
end if
if e.flags AND GUI_FLAG_SCROLL_V then
  if c = e.col2 then
    if r = e.scroll_loc_vert then
      e.flags = e.flags OR GUI_FLAG_SCROLL_IS_HELD_V
    end if
  end if
end if
END SUB

SUB GUI_process_scroll_wheel_scroll_bar (gui as GUI_element_type, mouse_event as GUI_event_mouse_type)
gui.scroll_offset_vert = gui.scroll_offset_vert + mouse_event.m.mscroll
if gui.scroll_offset_vert < 0 then gui.scroll_offset_vert = 0
if gui.scroll_offset_vert > gui.length - (gui.row2 - gui.row1 - 1) then
  gui.scroll_offset_vert = gui.length - (gui.row2 - gui.row1 - 1)
end if
GUI_calc_scroll gui.row1, gui.col1, gui.row2, gui.col2, gui
gui.flags = gui.flags OR GUI_FLAG_UPDATED
END SUB

'###############################################################################
'###############################################################################
'#---------------------------TEXT INPUT FUNCTIONS------------------------------#
'###############################################################################
'###############################################################################

'Call to add a string to the GUI element b (Should be a GUI_INPUT_BOX)
SUB GUI_add_character (b AS GUI_element_type, ch$)
t$ = MEM_get_str$(b.text)
col1 = b.text_sel_col1
col2 = b.text_sel_col2
if col1 > col2 then swap col1, col2
if col1 <> col2 then GUI_del_character b

t$ = MID$(t$, 1, b.text_position) + ch$ + MID$(t$, b.text_position + 1)
'print "T="; t$;
'_DISPLAY
'sleep
MEM_put_str b.text, t$
b.text_position = b.text_position + len(ch$)
IF b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 2) THEN
  b.scroll_offset_hors = b.text_position - (b.col2 - b.col1 - 2)
  'do
  '  b.scroll_offset_hors = b.scroll_offset_hors + 1
  'loop until b.text_position <= b.scroll_offset_hors + (b.col2 - b.col1 - 2)
END IF
END SUB

'Call to delete a single character from the GUI element b (Should be a GUI_INPUT_BOX)
SUB GUI_del_character (b AS GUI_element_type)
t$ = MEM_get_str$(b.text)
col1 = b.text_sel_col1
col2 = b.text_sel_col2
if col1 > col2 then swap col1, col2
IF LEN(t$) > 0 AND b.text_position > 0 AND col1 = col2 THEN
  t$ = MID$(t$, 1, b.text_position - 1) + MID$(t$, b.text_position + 1)
  MEM_put_str b.text, t$
  b.text_position = b.text_position - 1
  IF b.text_position < b.scroll_offset_hors THEN
    b.scroll_offset_hors = b.text_position + 1
  END IF
ELSEIF col1 <> col2 then
  t$ = mid$(t$, 1, col1) + mid$(t$, col2 + 1)
  MEM_put_str b.text, t$
  b.text_position = col1
  IF b.text_position < b.scroll_offset_hors THEN
    b.scroll_offset_hors = b.text_position - 1
  END IF
  b.text_sel_col1 = b.text_sel_col2
END IF
END SUB

SUB GUI_add_character_text_box (b AS GUI_element_type, ch$)
t$ = MEM_get_str_array$(b.lines, b.selected)
if len(t$) >= b.text_position then
  t$ = MID$(t$, 1, b.text_position) + ch$ + MID$(t$, b.text_position + 1)
else
  t$ = t$ + space$(b.text_position - len(t$)) + ch$
end if
'print "T="; t$;
'_DISPLAY
'sleep
MEM_put_str_array b.lines, b.selected, t$
b.text_position = b.text_position + 1
IF b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 2) THEN
  b.scroll_offset_hors = b.scroll_offset_hors + 1
END IF
END SUB

SUB GUI_del_character_text_box (b AS GUI_element_type)
t$ = MEM_get_str_array$(b.lines, b.selected)
IF LEN(t$) > 0 AND b.text_position > 0 and len(t$) >= b.text_position THEN
  t$ = MID$(t$, 1, b.text_position - 1) + MID$(t$, b.text_position + 1)
  MEM_put_str_array b.lines, b.selected, t$
  b.text_position = b.text_position - 1
  IF b.text_position < b.scroll_offset_hors THEN
    b.scroll_offset_hors = b.scroll_offset_hors - 1
  END IF
elseif len(t$) < b.text_position then
  do while b.text_position > len(t$)
    b.text_position = b.text_position - 1
    IF b.text_position < b.scroll_offset_hors THEN
      b.scroll_offset_hors = b.scroll_offset_hors - 1
    END IF
  loop
elseif b.text_position = 0 and b.selected > 1 then
  'append text to line above, shift all lines below the selected one up, decrease selected line
  k$ = MEM_get_str_array$(b.lines, b.selected - 1)
  lengt = len(k$)
  MEM_put_str_array b.lines, b.selected - 1, (k$ + t$)
  for x = b.selected to b.length - 1
    MEM_put_str_array b.lines, x, MEM_get_str_array$(b.lines, x + 1)
  next x
  MEM_put_str_array b.lines, b.length, ""
  b.selected = b.selected - 1
  b.length = b.length - 1
  b.text_position = lengt
  if b.selected < b.scroll_offset_vert then
    b.scroll_offset_vert = b.scroll_offset_vert - 1
  end if
  if b.text_position < b.scroll_offset_hors then
    do while b.text_position < b.scroll_offset_hors
      b.text_position = b.text_position + 1
    loop
  elseif b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 1) then
    do while b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 1)
      b.scroll_offset_hors = b.scroll_offset_hors + 1
    loop
  end if
END IF
GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
END SUB

SUB GUI_move_cursor_left (b as GUI_element_type, e as GUI_event_key_type)
IF b.text_position > 0 THEN
  b.text_position = b.text_position - 1
  IF b.text_position < b.scroll_offset_hors THEN
    b.scroll_offset_hors = b.scroll_offset_hors - 1
  END IF
  b.flags = b.flags OR GUI_FLAG_UPDATED
  GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
  if e.flags AND GUI_EVENT_KEY_RIGHT_SHIFT_DOWN OR e.flags AND GUI_EVENT_KEY_LEFT_SHIFT_DOWN then
    b.text_sel_col1 = b.text_position
    b.text_sel_col2 = b.text_sel_col1
  else
    b.text_sel_col2 = b.text_position
  end if
END IF
END SUB

SUB GUI_move_cursor_right (b as GUI_element_type, e as GUI_event_key_type)
IF (b.text_position < b.text.length AND b.element_type = GUI_INPUT_BOX) OR b.element_type = GUI_TEXT_BOX THEN
  b.text_position = b.text_position + 1
  IF b.text_position > b.scroll_offset_hors + (b.col2 - b.col1 - 1) THEN
    b.scroll_offset_hors = b.scroll_offset_hors + 1
  END IF
  b.flags = b.flags OR GUI_FLAG_UPDATED
  GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
  if e.flags AND GUI_EVENT_KEY_RIGHT_SHIFT_DOWN OR e.flags AND GUI_EVENT_KEY_LEFT_SHIFT_DOWN then
    b.text_sel_col1 = b.text_position
    b.text_sel_col2 = b.text_sel_col1
  else
    b.text_sel_col2 = b.text_position
  end if
end if
END SUB

SUB GUI_move_cursor_up (b as GUI_element_type, e as GUI_event_key_type)
if b.selected > 1 then
  b.selected = b.selected - 1
  GUI_fix_scroll b
  GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
  b.flags = b.flags OR GUI_FLAG_UPDATED
end if
END SUB

SUB GUI_move_cursor_down (b as GUI_element_type, e as GUI_event_key_type)
if b.selected < b.length then
  b.selected = b.selected + 1
  GUI_fix_scroll b
  GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
  b.flags = b.flags OR GUI_FLAG_UPDATED
end if
END SUB

SUB GUI_text_box_handle_enter_key (b as GUI_element_type, e as GUI_event_key_type)
tex$ = mid$(MEM_get_str_array$(b.lines, b.selected), b.text_position + 1)

if b.length + 1 > b.lines.allocated and (b.length < b.max_lines OR b.max_lines = 0) then
  MEM_allocate_string_array b.lines, b.length + 10
  b.length = b.length + 1
elseif b.length < b.max_lines OR b.max_lines = 0 then
  b.length = b.length + 1
end if

for x = b.length to b.selected + 1 STEP -1
  MEM_put_str_array b.lines, x, MEM_get_str_array$(b.lines, x - 1)
next x

MEM_put_str_array b.lines, b.selected + 1, tex$
MEM_put_str_array b.lines, b.selected, mid$(MEM_get_str_array$(b.lines, b.selected), 1, b.text_position)
b.selected = b.selected + 1
if b.selected > b.length then
  b.selected = b.selected - 1
end if
b.text_position = 0
b.scroll_offset_hors = 0
b.flags = b.flags OR GUI_FLAG_UPDATED
if b.selected > b.scroll_offset_vert + (b.row2 - b.row1 - 1) then
  b.scroll_offset_vert = b.scroll_offset_vert + 1
end if

GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
END SUB

SUB GUI_move_cursor_page_up (b as GUI_element_type, e as GUI_event_key_type)
b.selected = b.selected - (b.row2 - b.row1 - 1)
if b.selected < 1 then b.selected = 1
GUI_fix_scroll b
GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
b.flags = b.flags OR GUI_FLAG_UPDATED
END SUB

SUB GUI_move_cursor_page_down (b as GUI_element_type, e as GUI_event_key_type)
b.selected = b.selected + (b.row2 - b.row1 - 1)
if b.selected > b.length then b.selected = b.length
GUI_fix_scroll b
GUI_calc_scroll b.row1, b.col1, b.row2, b.col2, b
b.flags = b.flags OR GUI_FLAG_UPDATED
END SUB

SUB GUI_grab_key_events ()
DIM e as GUI_event_generic_type, k as GUI_event_key_type

GUI_init_event e
e.event_type = GUI_EVENT_KEY

ch = _KEYHIT

if ch <= 0 then
  ch = -ch
  key_release = -1
end if

k.key_code = ch
if ch > 0 then
  SELECT CASE ch
    CASE GUI_KEY_CODE_LMETA
      if key_release then GUI_LMETA_FLAG = 0      ELSE GUI_LMETA_FLAG = GUI_EVENT_KEY_LEFT_META_DOWN
    CASE GUI_KEY_CODE_RMETA
      if key_release then GUI_RMETA_FLAG = 0      ELSE GUI_RMETA_FLAG = GUI_EVENT_KEY_RIGHT_META_DOWN
    CASE GUI_KEY_CODE_RAPPLE
      if key_release then GUI_RAPPLE_FLAG = 0     ELSE GUI_RAPPLE_FLAG = GUI_EVENT_KEY_RIGHT_APPLE_DOWN
    CASE GUI_KEY_CODE_LAPPLE
      if key_release then GUI_LAPPLE_FLAG = 0     ELSE GUI_LAPPLE_FLAG = GUI_EVENT_KEY_LEFT_APPLE_DOWN
    CASE GUI_KEY_CODE_LCTRL
      if key_release then GUI_LCTRL_FLAG = 0      ELSE GUI_LCTRL_FLAG = GUI_EVENT_KEY_LEFT_CTRL_DOWN
    CASE GUI_KEY_CODE_RCTRL
      if key_release then GUI_RCTRL_FLAG = 0      ELSE GUI_RCTRL_FLAG = GUI_EVENT_KEY_RIGHT_CTRL_DOWN
    CASE GUI_KEY_CODE_LSHIFT
      if key_release then GUI_LSHIFT_FLAG = 0     ELSE GUI_LSHIFT_FLAG = GUI_EVENT_KEY_LEFT_SHIFT_DOWN
    CASE GUI_KEY_CODE_RSHIFT
      if key_release then GUI_RSHIFT_FLAG = 0     ELSE GUI_RSHIFT_FLAG = GUI_EVENT_KEY_RIGHT_SHIFT_DOWNf
    CASE GUI_KEY_CODE_LALT
      if key_release then GUI_LALT_FLAG = 0       ELSE GUI_LALT_FLAG = GUI_EVENT_KEY_LEFT_ALT_DOWN
    CASE GUI_KEY_CODE_RALT
      if key_release then GUI_RALT_FLAG = 0       ELSE GUI_RALT_FLAG = GUI_EVENT_KEY_RIGHT_ALT_DOWN
    CASE GUI_KEY_CODE_CAPSLOCK
      if key_release then GUI_CAPS_LOCK_FLAG = 0  ELSE GUI_CAPS_LOCK_FLAG = GUI_EVENT_KEY_CAPS_LOCK_DOWN
    CASE GUI_KEY_CODE_ALT_GR
      if key_release then GUI_ALT_GR_FLAG = 0     ELSE GUI_ALT_GR_FLAG = GUI_EVENT_KEY_ALT_GR_DOWN
  END SELECT
  k.flags = GUI_EVENT_KEY_LEFT_ALT_DOWN OR GUI_EVENT_KEY_RIGHT_ALT_DOWN OR GUI_EVENT_KEY_LEFT_ALT_DOWN OR GUI_EVENT_KEY_RIGHT_ALT_DOWN OR GUI_EVENT_KEY_LEFT_CTL_DOWN OR GUI_EVENT_KEY_RIGHT_CTL_DOWN OR GUI_EVENT_KEY_LEFT_META_DOWN OR GUI_EVENT_KEY_RIGHT_META_DOWN OR GUI_EVENT_KEY_LEFT_SHIFT_DOWN OR GUI_EVENT_KEY_RIGHT_SHIFT_DOWN OR GUI_EVENT_KEY_CAPS_LOCK_DOWN OR GUI_EVENT_KEY_ALT_GR_DOWN 
  if key_release then
    k.flags = k.flags OR GUI_EVENT_KEY_RELEASED
    _MEMPUT e.mem, e.mem.OFFSET, k
    GUI_add_event_to_queue e
  elseif NOT key_release then
    k.flags = k.flags OR GUI_EVENT_KEY_PRESSED
    _MEMPUT e.mem, e.mem.OFFSET, k
    GUI_add_event_to_queue e
    if ch >= 32 and ch <= ASC("~") then
      k.flags = (k.flags AND NOT GUI_EVENT_KEY_PRESSED) OR GUI_EVENT_KEY_TYPED
      _MEMPUT e.mem, e.mem.OFFSET, k
      GUI_add_event_to_queue e
    end if
  end if
end if

GUI_free_event e

END SUB

SUB GUI_process_key_event (gui() as GUI_element_type, gui_num as INTEGER, sel, e as GUI_event_generic_type)
'Special case for the Alt key
DIM k_event as GUI_event_key_type
GUI_get_key_event e, k_event

SELECT CASE gui(sel).element_type
  CASE GUI_BOX
    GUI_box_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_INPUT_BOX
    GUI_input_box_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_TEXT_BOX
    GUI_text_box_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_LIST_BOX
    GUI_list_box_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_DROP_DOWN
    GUI_drop_down_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_CHECKBOX
    GUI_checkbox_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_MENU
    GUI_menu_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_BUTTON
    GUI_button_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_RADIO_BUTTON
    GUI_radio_button_process_key_event gui(), gui_num, sel, k_event
  CASE GUI_LABEL
    GUI_label_process_key_event gui(), gui_num, sel, k_event
END SELECT

'Any element that doesn't want TAB handled internally should set the key_code equal to 0 (Or anything besdes GUI_KEY_CODE_TAB)
if k_event.flags AND GUI_EVENT_KEY_PRESSED AND k_event.key_code = GUI_KEY_CODE_TAB then
  do
    sel = (sel mod gui_num) + 1
  loop until (gui(sel).flags AND GUI_FLAG_SKIP) = 0
  gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
end if

IF k_event.flags AND GUI_EVENT_KEY_PRESSED AND (k_event.key_code = GUI_KEY_CODE_RALT OR k_event.key_code = GUI_KEY_CODE_LALT) then
  GUI_debug_output "Here"
end if

END SUB

FUNCTION GUI_inkey$ (gui() AS GUI_element_type, gui_num AS INTEGER, sel)
DIM tempm AS GUI_menu_item_type, men AS GUI_menu_item_type, tmpm AS GUI_menu_item_type
DIM memtmp as _MEM, offset as _OFFSET
DIM ch as LONG
ch = _KEYHIT
if ch > 0 then GUI_debug_output "Keypress: " + str$(ch)

if ch <= 0 then
  ch = -ch
  key_release = -1
  GUI_LAST_KEYPRESS = 0
  GUI_KEYPRESS_TIMER = 0
  GUI_KEYPRESS_REPEATING = 0
elseif ch > 0 then
  key_release = 0
  GUI_LAST_KEYPRESS = ch
  GUI_KEYPRESS_TIMER = TIMER(.001)
elseif NOT GUI_KEYPRESS_REPEATING then
  if (GUI_KEYPRESS_TIMER - TIMER(.001)) > GUI_KEYPRESS_DELAY then
    GUI_KEYPRESS_REPEATING = -1
    ch = GUI_LAST_KEYPRESS
    GUI_KEYPRESS_TIMER = TIMER(.001)
  end if
elseif GUI_KEYPRESS_REPEATING then
  if GUI_KEYPRESS_TIMER - TIMER(.001) > GUI_KEYPRESS_REPEAT_DELAY then
    GUI_KEYPRESS_REPEATING = -1
    ch = GUI_LAST_KEYPRESS
    GUI_KEYPRESS_TIMER = TIMER(.001)
  end if
end if

if ch > 0 then
  if ch >= 255 and ch < 65535 then
    GUI_debug_output "INKEY$:" + CHR$(ch \ 255) + CHR$(ch AND 255)
  elseif ch < 256 then
    GUI_debug_output "INKEY$:" + CHR$(ch)
  end if
end if

keys = (ch = 100307) OR (ch = 100308)
IF (keys) AND NOT key_release AND GUI_alt_flag = 0 THEN 'Alt Hold
  GUI_debug_output "Alt Held"
  GUI_alt_flag = -1
  'Switch to menu item if one is in gui()
  if gui(sel).element_type <> GUI_MENU or (((gui(sel).flags AND GUI_FLAG_MENU_OPEN) OR (gui(sel).flags AND GUI_FLAG_MENU_ALT)) = 0) then
    for x = 1 to gui_num
      if gui(x).element_type = GUI_MENU then
        gui(x).flags = (gui(x).flags OR GUI_FLAG_MENU_ALT OR GUI_FLAG_UPDATED) AND NOT GUI_FLAG_MENU_OPEN
        gui(x).selected_old = sel
        sel = x 'change selected
      end if
    next x
  elseif gui(sel).element_type = GUI_MENU and (gui(sel).flags AND GUI_FLAG_MENU_OPEN) then
    gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
  end if
END IF
IF keys AND key_release AND GUI_alt_flag THEN 'Alt Release
  GUI_debug_output "Alt Release"
  GUI_alt_flag = 0
  if gui(sel).flags AND GUI_FLAG_MENU_ALT then
    gui(sel).flags = gui(sel).flags AND NOT GUI_FLAG_MENU_ALT
    if gui(sel).selected > 0 then
      men = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), GUI_menu_item_type)
      men.selected = 1
      _MEMPUT gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (gui(sel).selected - 1), men
    elseif gui(sel).selected = 0 then
      sel = gui(sel).selected_old
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    end if
  elseif gui(sel).flags AND GUI_FLAG_MENU_OPEN then
    gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
  end if
END IF
keys = (ch = 100305) OR (ch = 100306)
if keys AND NOT key_release AND GUI_ctl_flag = 0 THEN 'Ctl hold
  GUI_debug_output "Ctl Held"
  GUI_ctl_flag = -1
end if
if keys = 0 AND key_release AND GUI_ctl_flag then 'Ctl Release
  GUI_debug_output "Ctl Release"
  GUI_ctl_flag = 0
end if

keys = (ch = 100303) OR (ch = 100304)
if keys AND NOT key_release AND GUI_shift_flag = 0 then
  GUI_debug_output "Shift Held"
  GUI_shift_flag = -1
end if
if keys AND key_release AND GUI_shift_flag then
  GUI_debug_output "Shift Release"
  GUI_shift_flag = 0
end if

if not key_release and not GUI_alt_flag and not GUI_ctl_flag then
  SELECT CASE ch
    CASE ASC(" ") TO ASC("~") 'typeable character
      if gui(sel).element_type = GUI_INPUT_BOX then
        GUI_add_character gui(sel), chr$(ch)
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      ELSEIF gui(sel).element_type = GUI_TEXT_BOX then
        GUI_add_character_text_box gui(sel), chr$(ch)
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      elseif ch = asc(" ") and gui(sel).element_type = GUI_CHECKBOX then
        gui(sel).flags = (gui(sel).flags XOR GUI_FLAG_CHECKED) OR GUI_FLAG_UPDATED
      elseif ch = asc(" ") and gui(sel).element_type = GUI_RADIO_BUTTON then
        gui(sel).flags = (gui(sel).flags OR GUI_FLAG_CHECKED) OR GUI_FLAG_UPDATED
        FOR x = 1 to gui_num
          if x <> sel then
            if gui(x).element_type = GUI_RADIO_BUTTON then
              if gui(x).group = gui(sel).group then
                gui(x).flags = gui(x).flags AND NOT GUI_FLAG_CHECKED
              end if
            end if
          end if
        NEXT x
      elseif ch = asc(" ") and gui(sel).element_type = GUI_BUTTON then
        GUI_queue_mouse_click sel
      end if
    CASE 8 'BACKSPACE
      if gui(sel).element_type = GUI_INPUT_BOX then
        GUI_del_character gui(sel)
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      elseif gui(sel).element_type = GUI_TEXT_BOX then
        GUI_del_character_text_box gui(sel)
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      end if
    CASE 9 'Tab
      do
        sel = (sel mod gui_num) + 1
      loop until (gui(sel).flags AND GUI_FLAG_SKIP) = 0
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
    CASE 13 'Enter
      if gui(sel).element_type = GUI_TEXT_BOX then
        tex$ = mid$(MEM_get_str_array$(gui(sel).lines, gui(sel).selected), gui(sel).text_position + 1)
  
        if gui(sel).length + 1 > gui(sel).lines.allocated and (gui(sel).length < gui(sel).max_lines OR gui(sel).max_lines = 0) then
          MEM_allocate_string_array gui(sel).lines, gui(sel).length + 10
          gui(sel).length = gui(sel).length + 1
        elseif gui(sel).length < gui(sel).max_lines OR gui(sel).max_lines = 0 then
          gui(sel).length = gui(sel).length + 1
        end if
  
        for x = gui(sel).length to gui(sel).selected + 1 STEP -1
          MEM_put_str_array gui(sel).lines, x, MEM_get_str_array$(gui(sel).lines, x - 1)
        next x
  
        MEM_put_str_array gui(sel).lines, gui(sel).selected + 1, tex$
        MEM_put_str_array gui(sel).lines, gui(sel).selected, mid$(MEM_get_str_array$(gui(sel).lines, gui(sel).selected), 1, gui(sel).text_position)
        gui(sel).selected = gui(sel).selected + 1
        if gui(sel).selected > gui(sel).length then
          gui(sel).selected = gui(sel).selected - 1
        end if
        gui(sel).text_position = 0
        gui(sel).scroll_offset_hors = 0
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
        if gui(sel).selected > gui(sel).scroll_offset_vert + (gui(sel).row2 - gui(sel).row1 - 1) then
          gui(sel).scroll_offset_vert = gui(sel).scroll_offset_vert + 1
        end if
  
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
      elseif gui(sel).element_type = GUI_MENU then 'and gui(sel).selected > 0 then
        GUI_menu_movement 5, gui(sel)
      elseif gui(sel).element_type = GUI_BUTTON then
        GUI_queue_mouse_click sel
      elseif gui(sel).element_type = GUI_RADIO_BUTTON then
        gui(sel).flags = gui(sel).flags XOR GUI_FLAG_CHECKED
        FOR x = 1 to gui_num
          if x <> sel then
            if gui(x).element_type = GUI_RADIO_BUTTON then
              if gui(x).group = gui(sel).group then
                gui(x).flags = gui(sel).flags AND NOT GUI_FLAG_CHECKED
              end if
            end if
          end if
        NEXT x
      elseif gui(sel).element_type = GUI_CHECKBOX then
        gui(sel).flags = gui(sel).flags XOR GUI_FLAG_CHECKED
      elseif gui(sel).element_type = GUI_DROP_DOWN then
        gui(sel).flags = (gui(sel).flags XOR GUI_FLAG_DROP_FLAG) OR GUI_FLAG_UPDATED
      elseif gui(sel).element_type = GUI_LIST_BOX then
        GUI_queue_mouse_click sel
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      end if
    CASE CVI(CHR$(0) + CHR$(80)) 'DOWN
      if gui(sel).element_type = GUI_LIST_BOX OR gui(sel).element_type = GUI_TEXT_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND (gui(sel).flags AND GUI_FLAG_DROP_FLAG)) then
        if gui(sel).selected < gui(sel).length then
          gui(sel).selected = gui(sel).selected + 1
          GUI_fix_scroll gui(sel)
          GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
          gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
        end if
      ELSEIF gui(sel).element_type = GUI_DROP_DOWN then
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_DROP_FLAG
      ELSEIF gui(sel).element_type = GUI_MENU then 'and gui(sel).selected > 0  then
        GUI_menu_movement 3, gui(sel)
      end if
    CASE CVI(CHR$(0) + CHR$(72)) 'UP
      if gui(sel).element_type = GUI_LIST_BOX OR gui(sel).element_type = GUI_TEXT_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND (gui(sel).flags AND GUI_FLAG_DROP_FLAG))  then
        if gui(sel).selected > 1 then
          gui(sel).selected = gui(sel).selected - 1
          GUI_fix_scroll gui(sel)
          GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
          gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
        end if
      elseif gui(sel).element_type = GUI_MENU then
        GUI_menu_movement 1, gui(sel)
      end if
    CASE CVI(CHR$(0) + CHR$(75)) 'LEFT
      if gui(sel).element_type = GUI_INPUT_BOX OR gui(sel).element_type = GUI_TEXT_BOX then
        IF gui(sel).text_position > 0 THEN
          gui(sel).text_position = gui(sel).text_position - 1
          IF gui(sel).text_position < gui(sel).scroll_offset_hors THEN
            gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors - 1
          END IF
          gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
          GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
          if GUI_shift_flag = 0 then
            gui(sel).text_sel_col1 = gui(sel).text_position
            gui(sel).text_sel_col2 = gui(sel).text_sel_col1
          else
            gui(sel).text_sel_col2 = gui(sel).text_position
          end if
        END IF
      ELSEIF gui(sel).element_type = GUI_DROP_DOWN or gui(sel).element_type = GUI_LIST_BOX then
        if gui(sel).flags AND GUI_FLAG_SCROLL_H then
          if gui(sel).scroll_offset_hors > 0 then
            gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors - 1
            gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
            GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
          end if
        end if
      ELSEIF gui(sel).element_type = GUI_MENU then
        GUI_menu_movement 4, gui(sel)
      end if
    CASE CVI(CHR$(0) + CHR$(77)) 'RIGHT
      if gui(sel).element_type = GUI_INPUT_BOX OR gui(sel).element_type = GUI_TEXT_BOX then
        IF (gui(sel).text_position < gui(sel).text.length AND gui(sel).element_type = GUI_INPUT_BOX) OR gui(sel).element_type = GUI_TEXT_BOX THEN
          gui(sel).text_position = gui(sel).text_position + 1
          IF gui(sel).text_position > gui(sel).scroll_offset_hors + (gui(sel).col2 - gui(sel).col1 - 1) THEN
            gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors + 1
          END IF
          gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
          GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
          if GUI_shift_flag = 0 then
            gui(sel).text_sel_col1 = gui(sel).text_position
            gui(sel).text_sel_col2 = gui(sel).text_sel_col1
          else
            gui(sel).text_sel_col2 = gui(sel).text_position
          end if
        end if
      ELSEIF gui(sel).element_type = GUI_DROP_DOWN or gui(sel).element_type = GUI_LIST_BOX then
        if gui(sel).flags AND GUI_FLAG_SCROLL_H then
          if gui(sel).scroll_offset_hors < gui(sel).scroll_max_hors - (gui(sel).col2 - gui(sel).col1 - 1) then
            gui(sel).scroll_offset_hors = gui(sel).scroll_offset_hors + 1
            gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
            GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
          end if
        end if
      ELSEIF gui(sel).element_type = GUI_MENU then
        GUI_menu_movement 2, gui(sel)
  
      END IF
    CASE CVI(CHR$(0) + CHR$(73)) 'PageUp
      if gui(sel).element_type = GUI_LIST_BOX OR gui(sel).element_type = GUI_TEXT_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND (gui(sel).flags AND GUI_FLAG_DROP_FLAG))  then
        gui(sel).selected = gui(sel).selected - (gui(sel).row2 - gui(sel).row1 - 1)
        if gui(sel).selected < 1 then gui(sel).selected = 1
        GUI_fix_scroll gui(sel)
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      end if
    CASE CVI(CHR$(0) + CHR$(81)) 'PageDown
      if gui(sel).element_type = GUI_LIST_BOX OR gui(sel).element_type = GUI_TEXT_BOX OR (gui(sel).element_type = GUI_DROP_DOWN AND (gui(sel).flags AND GUI_FLAG_DROP_FLAG)) then
        gui(sel).selected = gui(sel).selected + (gui(sel).row2 - gui(sel).row1 - 1)
        if gui(sel).selected > gui(sel).length then gui(sel).selected = gui(sel).length
        GUI_fix_scroll gui(sel)
        GUI_calc_scroll gui(sel).row1, gui(sel).col1, gui(sel).row2, gui(sel).col2, gui(sel)
        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      end if
    case else
      'elseif GUI_ctl_flag and NOT GUI_alt_flag then
      '  if ch$ = chr$(22) then 'CTRL + V
      '    GUI_debug_output "Paste"
      '    SELECT CASE gui(sel).element_type
      '      CASE GUI_INPUT_BOX
      '        GUI_add_character gui(sel), _CLIPBOARD$
      '        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      '    END SELECT
      '  elseif ch$ = chr$(3) then 'CTRL + C
      '    GUI_debug_output "Copy"
      '    SELECT CASE gui(sel).element_type
      '      CASE GUI_INPUT_BOX
      '        t$ = MEM_get_str$(gui(sel).text)
      '        _CLIPBOARD$ = mid$(t$, gui(sel).text_sel_col1 + 1, gui(sel).text_sel_col2 - gui(sel).text_sel_col1)
      '    END SELECT
      '  elseif ch$ = chr$(24) then 'CTRL + X
      '    GUI_debug_output "Cut"
      '    SELECT CASE gui(sel).element_type
      '      CASE GUI_INPUT_BOX
      '        t$ = MEM_get_str$(gui(sel).text)
      '        _CLIPBOARD$ = mid$(t$, gui(sel).text_sel_col1 + 1, gui(sel).text_sel_col2 - gui(sel).text_sel_col1)
      '        GUI_del_character gui(sel)
      '        gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      '    END SELECT
      '  end if
      'end if
  END SELECT
end if

if not key_release and GUI_alt_flag then
  if ch < 256 and ch > 0 then
    k$ = ucase$(chr$(ch))
    GUI_debug_output "K=" + k$
    if gui(sel).element_type = GUI_MENU then
      if gui(sel).flags AND GUI_FLAG_MENU_OPEN then
        memtmp = gui(sel).menu
        offset = len(mtmp) * (gui(sel).selected - 1)
        tempm = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(tempm) * (gui(sel).selected - 1), GUI_menu_item_type)
        do
          men = _MEMGET(tempm.sub_menu, tempm.sub_menu.OFFSET + len(men) * (tempm.selected - 1), GUI_menu_item_type)
          if men.sub_menu_open then
            memtmp = tempm.sub_menu
            offset = len(tempm) * (tempm.selected - 1)
            tempm = men
          end if
        loop until not men.sub_menu_open
        GUI_debug_output "Nam= " + MEM_Get_str$(men.nam)
        for x = 1 to tempm.sub_menu_length
          tmpm = _MEMGET(tempm.sub_menu, tempm.sub_menu.OFFSET + len(tmpm) * (x - 1), GUI_menu_item_type)
          if k$ = ucase$(GUI_menu_char$(MEM_get_str$(tmpm.nam))) then
            if tmpm.has_sub then
              tmpm.sub_menu_open = -1
              tmpm.selected = 1
              GUI_close_sub_menu tmpm
              _MEMPUT tempm.sub_menu, tempm.sub_menu.OFFSET + len(tmpm) * (x - 1), tmpm
              tempm.selected = x
              _MEMPUT memtmp, memtmp.OFFSET + offset, tempm
              gui(sel).flags = (gui(sel).flags OR GUI_FLAG_UPDATED)
            else
              gui(sel).menu_choice = tmpm.ident
              gui(sel).flags = (gui(sel).flags OR GUI_FLAG_UPDATED OR GUI_FLAG_MENU_CHOSEN) AND NOT GUI_FLAG_MENU_OPEN
              gui(sel).selected = 0
            end if
          end if
        next x
      else
        for x = 1 to gui(sel).length
          men = _MEMGET(gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (x - 1), GUI_menu_item_type)
          if k$ = ucase$(GUI_menu_char$(MEM_get_str$(men.nam))) then
            gui(sel).selected = x
            gui(sel).flags = (gui(sel).flags OR GUI_FLAG_MENU_OPEN OR GUI_FLAG_UPDATED) AND NOT GUI_FLAG_MENU_ALT
            men.selected = 1
            _MEMPUT gui(sel).menu, gui(sel).menu.OFFSET + len(men) * (x - 1), men
          end if
        next x
      end if
    end if
  end if
end if

if ch < 256 and ch > 0 then
  GUI_inkey$ = chr$(ch)
elseif ch < 65536 then
  GUI_inkey$ = chr$(ch \ 255) + chr$(ch AND 255)
end if

END FUNCTION

FUNCTION GUI_move_to_next_gui (movement$, current_selected, gui() AS GUI_element_type, gui_num AS INTEGER)
'function moves to next gui based on
selected_row = gui(current_selected).row1
selected_col = gui(current_selected).col1
new_col = -1 'distance from selected object
new_row = -1
new_gui = -1
'DIM choices(UBOUND(gui)) AS INTEGER
'things are judged by distance
'in event that there are more then one selected item, which normally happens, we select the closer object

SELECT CASE movement$
  CASE CHR$(0) + CHR$(72) 'up
    FOR x = 1 TO gui_num
      IF gui(x).row1 < selected_row AND gui(x).row1 >= new_row THEN
        IF gui(x).col1 = new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_col = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).col1 < new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(80) 'down
    FOR x = 1 TO gui_num
      IF gui(x).row1 > selected_row AND (gui(x).row1 <= new_row OR new_row = -1) THEN
        IF gui(x).col1 = new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_col = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).col1 < new_col THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(75) 'left
    FOR x = 1 TO gui_num
      IF gui(x).col1 < selected_col AND (gui(x).col1 >= new_col) THEN
        IF gui(x).row1 = new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_row = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).row1 > new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
  CASE CHR$(0) + CHR$(77) 'right
    FOR x = 1 TO gui_num
      IF gui(x).col1 > selected_col AND (gui(x).col1 <= new_col OR new_col = -1) THEN
        IF gui(x).row1 = new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF new_row = -1 THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        ELSEIF gui(x).row1 < new_row THEN
          new_gui = x
          new_row = gui(x).row1
          new_col = gui(x).col1
        END IF
      END IF
    NEXT x
END SELECT
move_to_next_gui = new_gui
END FUNCTION

FUNCTION GUI_get_selected_text$ ()

END FUNCTION

'###############################################################################
'###############################################################################
'#------------------------------MOUSE FUNCTIONS--------------------------------#
'###############################################################################
'###############################################################################

SUB GUI_grab_mouse_events ()

'if _MOUSEINPUT = 0 then EXIT SUB

DIM m as GUI_event_mouse_type, e as GUI_event_generic_type
DIM m_state as GUI_mouse_state, old_state as GUI_mouse_state
DIM drag_row AS INTEGER, drag_col AS INTEGER

GUI_init_event e
e.event_type = GUI_EVENT_MOUSE
'GUI_debug_output "Grabbing mouse input..."
'Process mouse stuff
GUI_PERSISTANT_MOUSE_STATE.MSCROLL = 0
old_state = GUI_PERSISTANT_MOUSE_STATE



DO WHILE _MOUSEINPUT
  GUI_PERSISTANT_MOUSE_STATE.MSCROLL = GUI_PERSISTANT_MOUSE_STATE.MSCROLL + _MOUSEWHEEL
  GUI_PERSISTANT_MOUSE_STATE.MCOL = _MOUSEX
  GUI_PERSISTANT_MOUSE_STATE.MROW = _MOUSEY
  GUI_PERSISTANT_MOUSE_STATE.MLEFT = _MOUSEBUTTON(1)
  GUI_PERSISTANT_MOUSE_STATE.MRIGHT = _MOUSEBUTTON(2)
  GUI_PERSISTANT_MOUSE_STATE.MMIDDLE = _MOUSEBUTTON(3)
  
  
  m_state = GUI_PERSISTANT_MOUSE_STATE
  
  
    'GUI_debug_output "Mleft: " + str$(m_state.mleft)
    'GUI_debug_output "Row: " + str$(m_state.mrow)
    'GUI_debug_output "Col: " + str$(m_state.mcol)
  
  'end if
  'Set the row and col info
  m.m = m_state

  
  'Check for left button change
  if GUI_MOUSE_LAST_STATE.MLEFT <> m_state.MLEFT then
    'Check for mouse-up or mouse-down and register the event
    'GUI_debug_output "Left Click"
    if m_state.MLEFT = 0 then
      m.flags = GUI_EVENT_MOUSE_LEFT_UP
      GUI_DRAG_FLAG = 0
    else
      m.flags = GUI_EVENT_MOUSE_LEFT_DOWN
      m_down = -1
      if GUI_DRAG_FLAG = 0 then 
        GUI_DRAG_FLAG = GUI_MOUSE_DRAG_LEFT 
        GUI_DRAG_ROW = m_state.mrow
        GUI_DRAG_COL = m_state.mcol
      else 
        GUI_DRAG_FLAG = 0
      end if
    end if
    'GUI_debug_output "Writing event"
    _MEMPUT e.mem, e.mem.OFFSET, m
    GUI_add_event_to_queue e
    if (m.flags AND GUI_EVENT_MOUSE_LEFT_UP) AND GUI_MOVEMENT_FLAG = 0 then
      'Click -- Check timer to see if we can add to click count or just start it over
      if TIMER(.001) - GUI_LEFT_CLICK_TIMER <= GUI_DOUBLE_CLICK_DELAY then
        GUI_LEFT_CLICK_COUNT = GUI_LEFT_CLICK_COUNT + 1
      else
        GUI_LEFT_CLICK_COUNT = 1
      end if
      m.count = GUI_LEFT_CLICK_COUNT
      m.flags = GUI_EVENT_MOUSE_LEFT_CLICK
      'GUI_debug_output "Writing click event"
      _MEMPUT e.mem, e.mem.OFFSET, m
      'GUI_debug_output "Adding click"
      GUI_add_event_to_queue e
      'GUI_debug_output "Done adding click"
      m.count = 0
      GUI_LEFT_CLICK_TIMER = TIMER(.001)
    end if
  end if
  
  'Check for RIGHT button change
  if GUI_MOUSE_LAST_STATE.MRIGHT <> m_state.MRIGHT then
    'GUI_debug_output "Right Click"
    'Check for mouse-up or mouse-down and register the event
    if m_state.MRIGHT = 0 then
      m.flags = GUI_EVENT_MOUSE_RIGHT_UP
      GUI_DRAG_FLAG = 0
    else
      m.flags = GUI_EVENT_MOUSE_RIGHT_DOWN
      m_down = -1
       m_down = -1
      if GUI_DRAG_FLAG = 0 then 
        GUI_DRAG_FLAG = GUI_MOUSE_DRAG_RIGHT
        GUI_DRAG_ROW = m_state.mrow
        GUI_DRAG_COL = m_state.mcol
      else 
        GUI_DRAG_FLAG = 0
      end if
    end if
    _MEMPUT e.mem, e.mem.OFFSET, m
    GUI_add_event_to_queue e
    if (m.flags AND GUI_EVENT_MOUSE_RIGHT_UP) AND GUI_MOVEMENT_FLAG = 0 then
      'Click -- Check timer to see if we can add to click count or just start it over
      if TIMER(.001) - GUI_RIGHT_CLICK_TIMER <= GUI_DOUBLE_CLICK_DELAY then
        GUI_RIGHT_CLICK_COUNT = GUI_RIGHT_CLICK_COUNT + 1
      else
        GUI_RIGHT_CLICK_COUNT = 1
      end if
      m.count = GUI_RIGHT_CLICK_COUNT
      m.flags = GUI_EVENT_MOUSE_RIGHT_CLICK
      _MEMPUT e.mem, e.mem.OFFSET, m
      GUI_add_event_to_queue e
      m.count = 0
      GUI_RIGHT_CLICK_TIMER = TIMER(.001)
    end if
  end if
    
  'Check for MIDDLE button change
  if GUI_MOUSE_LAST_STATE.MMIDDLE <> m_state.MMIDDLE then
    'GUI_debug_output "Middle Click"
    'Check for mouse-up or mouse-down and register the event
    if m_state.MMIDDLE = 0 then
      m.flags = GUI_EVENT_MOUSE_MIDDLE_UP
      GUI_DRAG_FLAG = 0
    else
      m.flags = GUI_EVENT_MOUSE_MIDDLE_DOWN
      m_down = -1
       m_down = -1
      if GUI_DRAG_FLAG = 0 then 
        GUI_DRAG_FLAG = GUI_MOUSE_DRAG_MIDDLE
        GUI_DRAG_ROW = m_state.mrow
        GUI_DRAG_COL = m_state.mcol
      else 
        GUI_DRAG_FLAG = 0
      end if
    end if
    _MEMPUT e.mem, e.mem.OFFSET, m
    GUI_add_event_to_queue e
    if (m.flags AND GUI_EVENT_MOUSE_MIDDLE_UP) AND GUI_MOVEMENT_FLAG = 0 then
      'Click -- Check timer to see if we can add to click count or just start it over
      if TIMER(.001) - GUI_MIDDLE_CLICK_TIMER <= GUI_DOUBLE_CLICK_DELAY then
        GUI_MIDDLE_CLICK_COUNT = GUI_MIDDLE_CLICK_COUNT + 1
      else
        GUI_MIDDLE_CLICK_COUNT = 1
      end if
      m.count = GUI_MIDDLE_CLICK_COUNT
      m.flags = GUI_EVENT_MOUSE_MIDDLE_CLICK
      _MEMPUT e.mem, e.mem.OFFSET, m
      GUI_add_event_to_queue e
      m.count = 0
      GUI_MIDDLE_CLICK_TIMER = TIMER(.001)
    end if
  end if
  
  if m_state.mrow <> GUI_MOUSE_LAST_STATE.mrow or m_state.mcol <> GUI_MOUSE_LAST_STATE.mcol then GUI_MOVEMENT_FLAG = -1
  
  GUI_MOUSE_LAST_STATE = m_state
  
  IF m_down then GUI_MOVEMENT_FLAG = 0: m_down = 0
loop

'Scroll is the easiest -- If scrolling happened then add an event
if GUI_PERSISTANT_MOUSE_STATE.mscroll <> 0 then
  if GUI_PERSISTANT_MOUSE_STATE.mscroll > 0 then
    m.flags = GUI_EVENT_MOUSE_SCROLL_UP
  else
    m.flags = GUI_EVENT_MOUSE_SCROLL_DOWN
  end if
  _MEMPUT e.mem, e.mem.OFFSET, m
  GUI_add_event_to_queue e
  'Reset event
  m.flags = 0
end if

'We handle movements inbetween grabbing mouse state
if old_state.mrow <> GUI_PERSISTANT_MOUSE_STATE.mrow or old_state.mcol <> GUI_PERSISTANT_MOUSE_STATE.mcol then
  'Mouse movement
  m.flags = GUI_EVENT_MOUSE_MOVEMENT
  _MEMPUT e.mem, e.mem.OFFSET, m
  GUI_add_event_to_queue e
  m.flags = 0
  IF GUI_DRAG_FLAG then
    m.flags = GUI_EVENT_MOUSE_DRAG
    _MEMPUT e.mem, e.mem.OFFSET, m
    GUI_add_event_to_queue e
  end if
end if

GUI_free_event e
'GUI_debug_output "Done reading mouse events"
END SUB

SUB GUI_process_mouse_event (b() as GUI_element_type, boxnum, selected_gui, event as GUI_event_generic_type)

DIM men as GUI_menu_item_type, mtmp as GUI_menu_item_type, mnext as GUI_menu_item_type
DIM memtmp AS _MEM, offset as _OFFSET

DIM mouse_event as GUI_event_mouse_type
GUI_get_mouse_event event, mouse_event

current_layer = -129
found = -1
FOR x = 1 TO boxnum

  select case b(x).element_type
    case GUI_BOX
      k = GUI_box_should_handle_event(b(x), mouse_event)
    case GUI_INPUT_BOX
      k = GUI_input_box_should_handle_event(b(x), mouse_event)
    case GUI_LIST_BOX
      k = GUI_list_box_should_handle_event(b(x), mouse_event)
    case GUI_TEXT_BOX
      k = GUI_text_box_should_handle_event(b(x), mouse_event)
    case GUI_DROP_DOWN
      k = GUI_drop_down_should_handle_event(b(x), mouse_event)
    case GUI_CHECKBOX
      k = GUI_checkbox_should_handle_event(b(x), mouse_event)
    case GUI_MENU
      k = GUI_menu_should_handle_event(b(x), mouse_event)
    case GUI_BUTTON
      k = GUI_button_should_handle_event(b(x), mouse_event)
    case GUI_RADIO_BUTTON
      k = GUI_radio_button_should_handle_event(b(x), mouse_event)
    CASE GUI_LABEL
      k = GUI_label_should_handle_event(b(x), mouse_event)
  END SELECT
  
  if k > current_layer then
    GUI_debug_output "Found: " + str$(x) + str$(k)
    found = x
    current_layer = k
  end if

NEXT x

if found <> selected_gui and found >= 1 then
  SELECT CASE b(found).element_type
    CASE GUI_BOX
      GUI_box_process_focus_release b(), boxnum, selected_gui
    CASE GUI_INPUT_BOX
      GUI_input_box_process_focus_release b(), boxnum, selected_gui
    CASE GUI_TEXT_BOX
      GUI_text_box_process_focus_release b(), boxnum, selected_gui
    CASE GUI_LIST_BOX
      GUI_list_box_process_focus_release b(), boxnum, selected_gui
    CASE GUI_DROP_DOWN
      GUI_drop_down_process_focus_release b(), boxnum, selected_gui
    CASE GUI_CHECKBOX
      GUI_checkbox_process_focus_release b(), boxnum, selected_gui
    CASE GUI_MENU
      GUI_menu_process_focus_release b(), boxnum, selected_gui
    CASE GUI_BUTTON
      GUI_button_process_focus_release b(), boxnum, selected_gui
    CASE GUI_RADIO_BUTTON
      GUI_radio_button_process_focus_release b(), boxnum, selected_gui
    CASE GUI_LABEL
      GUI_label_process_focus_release b(), boxnum, selected_gui
  END SELECT
end if

if found >= 1 then
  SELECT CASE b(found).element_type
    CASE GUI_BOX
      GUI_box_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_INPUT_BOX
      GUI_input_box_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_TEXT_BOX
      GUI_text_box_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_LIST_BOX
      GUI_list_box_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_DROP_DOWN
      GUI_drop_down_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_CHECKBOX
      GUI_checkbox_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_MENU
      GUI_menu_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_BUTTON
      GUI_button_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_RADIO_BUTTON
      GUI_radio_button_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
    CASE GUI_LABEL
      GUI_label_process_mouse_event b(), boxnum, selected_gui, found, mouse_event
  END SELECT

  selected_gui = found
end if

END SUB

'Records the GUI number sel to be queued up for a mouse click
'This happens for things such as pressing enter on a button
SUB GUI_queue_mouse_click (sel)
GUI_MOUSE_QUEUE$ = ltrim$(rtrim$(str$(sel))) + " " + GUI_MOUSE_QUEUE$
END SUB

'This function returns a queued mouse event, if one is there.
FUNCTION GUI_read_mouse_queue ()
if GUI_MOUSE_QUEUE$ > "" then
  s = val(GUI_MOUSE_QUEUE$)
  GUI_MOUSE_QUEUE$ = mid$(GUI_MOUSE_QUEUE$, instr(GUI_MOUSE_QUEUE$, " ") + 1)
  GUI_read_mouse_queue = s
end if
END FUNCTION

'###############################################################################
'###############################################################################
'#------------------------------EVENT FUNCTIONS--------------------------------#
'###############################################################################
'###############################################################################

SUB GUI_handle_events () ',e as GUI_event_generic_type)

'GUI_debug_output "Grabbing Mouse events..."
GUI_grab_mouse_events
'GUI_debug_output "Grabbing key events..."
GUI_grab_key_events 

END SUB

FUNCTION GUI_events_in_queue ()
GUI_events_in_queue = GUI_EVENT_STACK_LENGTH
END FUNCTION

SUB GUI_read_event (gui() as GUI_element_type, gui_num, sel, e as GUI_event_generic_type)
if GUI_EVENT_STACK_LENGTH > 0 then
  GUI_get_event_from_queue e
  'Do some in-house processing on the event first
  if e.event_type = GUI_EVENT_KEY then
    GUI_process_key_event gui(), gui_num, sel, e
  elseif e.event_type = GUI_EVENT_MOUSE then
    GUI_process_mouse_event gui(), gui_num, sel, e
  end if
else
  e.event_type = 0
end if
END SUB

SUB GUI_add_event_to_queue (e as GUI_event_generic_type)
DIM s as GUI_event_stack_link, stmp as GUI_event_stack_link
DIM mtmp as _MEM
GUI_init_event s.g
_MEMCOPY e.mem, e.mem.OFFSET, e.allocated TO s.g.mem, s.g.mem.OFFSET
s.g.allocated = e.allocated
s.g.event_type = e.event_type
mtmp = _MEMNEW(LEN(s))
if GUI_EVENT_STACK_LENGTH = 0 then
  GUI_EVENT_STACK_START = mtmp
  's.e_next = GUI_EVENT_STACK_START
elseif GUI_EVENT_STACK_LENGTH = 1 then
  'GUI_EVENT_STACK_START.e_next = mtmp
  GUI_EVENT_STACK_END = mtmp
  _MEMGET GUI_EVENT_STACK_START, GUI_EVENT_STACK_START.OFFSET, stmp
  stmp.e_prev = GUI_EVENT_STACK_END
  _MEMPUT GUI_EVENT_STACK_START, GUI_EVENT_STACK_START.OFFSET, stmp
  's.e_prev = GUI_EVENT_STACK_START
else
  _MEMGET GUI_EVENT_STACK_END, GUI_EVENT_STACK_END.OFFSET, stmp
  stmp.e_prev = mtmp
  _MEMPUT GUI_EVENT_STACK_END, GUI_EVENT_STACK_END.OFFSET, stmp
  
  's.e_prev = GUI_EVENT_STACK_START
  'GUI_EVENT_STACK_END.e_next = mtmp
  GUI_EVENT_STACK_END = mtmp
end if
  
_MEMPUT mtmp, mtmp.OFFSET, s
GUI_EVENT_STACK_LENGTH = GUI_EVENT_STACK_LENGTH + 1
'GUI_debug_output "Done adding to stack"
END SUB

SUB GUI_get_event_from_queue (e as GUI_event_generic_type)
DIM s as GUI_event_stack_link, mempty as _MEM
'GUI_debug_output "Taking from stack"
'IF GUI_EVENT_STACK_LENGTH = 1 then
  _MEMGET GUI_EVENT_STACK_START, GUI_EVENT_STACK_START.OFFSET, s
  _MEMFREE GUI_EVENT_STACK_START
  
if GUI_EVENT_STACK_LENGTH > 1 then
  GUI_EVENT_STACK_START = s.e_prev
end if
'elseif GUI_EVENT_STACK_LENGTH = 2 then
'  _MEMGET GUI_EVENT_STACK_START, GUI_EVENT_STACK_START.OFFSET, s
'  _MEMFREE GUI_EVENT_STACK_START
 
'else
'  _MEMGET GUI_EVENT_STACK_END, GUI_EVENT_STACK_END.OFFSET, s
'  _MEMFREE GUI_EVENT_STACK_END
'  GUI_EVENT_STACK_END = s.e_prev
  
'end if
'_MEMGET GUI_EVENT_STACK_START, GUI_EVENT_STACK_START.OFFSET, s
'_MEMFREE GUI_EVENT_STACK_START

'GUI_EVENT_STACK_START = s.e_next
_MEMCOPY s.g.mem, s.g.mem.OFFSET, s.g.allocated TO e.mem, e.mem.OFFSET
e.event_type = s.g.event_type
GUI_free_event s.g

GUI_EVENT_STACK_LENGTH = GUI_EVENT_STACK_LENGTH - 1
'GUI_debug_output "Done taking from stack"
END SUB

'Allocates a generic events memory
SUB GUI_init_event (e as GUI_event_generic_type)
e.mem = _MEMNEW(60) 'Size of the biggest event
e.allocated = 60
END SUB

'Frees a generic events memory
SUB GUI_free_event (e as GUI_event_generic_type)
_MEMFREE e.mem
e.allocated = 0
END SUB

SUB GUI_get_key_event (e as GUI_event_generic_type, e2 as GUI_event_key_type)
e2 = _MEMGET(e.mem, e.mem.OFFSET, GUI_event_key_type)
END SUB

SUB GUI_get_mouse_event (e as GUI_event_generic_type, e2 as GUI_event_mouse_type)
e2 = _MEMGET(e.mem, e.mem.OFFSET, GUI_event_mouse_type)
END SUB

SUB GUI_get_element_label_event (e as GUI_event_generic_type, e2 as GUI_event_element_label_type)
_MEMGET e.mem, e.mem.OFFSET, e2
END SUB

SUB GUI_get_element_button_event (e as GUI_event_generic_type, e2 as GUI_event_element_button_type)
_MEMGET e.mem, e.mem.OFFSET, e2
END SUB

'###############################################################################
'###############################################################################
'#-------------------------ELEMENT CLICK FUNCTIONS-----------------------------#
'###############################################################################
'###############################################################################
'Functions return TRUE (-1) if the event is sufficent to result in the GUI being
'selected

FUNCTION GUI_box_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_box_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN or event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN then
  IF event.m.mrow <= e.row2 AND event.m.mrow >= e.row1 THEN
    IF event.m.mcol >= e.col1 AND event.m.mcol <= e.col2 THEN
      GUI_box_should_handle_event = e.layer
    END IF
  END IF
end if
END FUNCTION

FUNCTION GUI_input_box_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_input_box_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN or event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN then
  IF event.m.mrow <= e.row1 + 2 AND event.m.mrow >= e.row1 THEN
    IF event.m.mcol >= e.col1 AND event.m.mcol <= e.col2 THEN
      GUI_input_box_should_handle_event = e.layer
    END IF
  END IF
end if
END FUNCTION

FUNCTION GUI_list_box_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_list_box_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK or event.flags AND GUI_EVENT_MOUSE_DRAG OR event.flags AND GUI_EVENT_MOUSE_SCROLL_DOWN OR event.flags AND GUI_EVENT_MOUSE_SCROLL_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN then
  if e.flags AND GUI_FLAG_SCROLL_IS_HELD_H OR e.flags AND GUI_FLAG_SCROLL_IS_HELD_V then
    GUI_list_box_should_handle_event = 128
  elseIF event.m.mrow <= e.row2 AND event.m.mrow >= e.row1 THEN
    IF event.m.mcol >= e.col1 AND event.m.mcol <= e.col2 THEN
      GUI_list_box_should_handle_event = e.layer
    END IF
  END IF
'elseif event.flags AND GUI_EVENT_MOUSE_DRAG then
  
'  end if
end if
END FUNCTION

FUNCTION GUI_text_box_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_text_box_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK OR event.flags AND GUI_EVENT_MOUSE_DRAG OR event.flags AND GUI_EVENT_MOUSE_SCROLL_DOWN OR event.flags AND GUI_EVENT_MOUSE_SCROLL_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN then
  if e.flags AND GUI_FLAG_SCROLL_IS_HELD_H OR e.flags AND GUI_FLAG_SCROLL_IS_HELD_V then
    GUI_text_box_should_handle_event = 128
  elseIF event.m.mrow <= e.row2 AND event.m.mrow >= e.row1 THEN
    IF event.m.mcol >= e.col1 AND event.m.mcol <= e.col2 THEN
      GUI_text_box_should_handle_event = e.layer
    END IF
  END IF
'elseif event.flags AND GUI_EVENT_MOUSE_DRAG then
'  i
'  end if
end if
END FUNCTION

FUNCTION GUI_drop_down_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_drop_down_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK OR event.flags AND GUI_EVENT_MOUSE_DRAG OR event.flags AND GUI_EVENT_MOUSE_SCROLL_DOWN OR event.flags AND GUI_EVENT_MOUSE_SCROLL_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN then
  if e.flags AND GUI_FLAG_SCROLL_IS_HELD_H OR e.flags AND GUI_FLAG_SCROLL_IS_HELD_V then
    GUI_drop_down_should_handle_event = 128
  elseif (e.flags AND GUI_FLAG_DROP_FLAG) <> GUI_FLAG_DROP_FLAG then
    'GUI_debug_output "Result: " + str$(NOT (b(x).flags AND GUI_FLAG_DROP_FLAG))
    IF event.m.mrow = e.row1 AND event.m.mcol >= e.col1 AND event.m.mcol <= e.col2 THEN
      GUI_drop_down_should_handle_event = e.layer
    END IF
  else
    if event.m.mrow >= e.row1 and event.m.mrow <= e.row2 and event.m.mcol >= e.col1 and event.m.mcol <= e.col2 then
      GUI_drop_down_should_handle_event = 128
    end if
  end if
'elseif event.flags AND GUI_EVENT_MOUSE_DRAG then
' 
'  end if
end if
END FUNCTION

FUNCTION GUI_checkbox_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_checkbox_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  IF event.m.mrow = e.row1 AND event.m.mcol >= e.col1 AND event.m.mcol <= e.col1 + 2 + e.nam.length THEN
    GUI_checkbox_should_handle_event = e.layer
  END IF
end if
END FUNCTION

FUNCTION GUI_menu_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_menu_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN or event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN then
  if GUI_menu_clicked_on(e, event.m.mcol, event.m.mrow, depth, selection) then
    GUI_debug_output "Inside menu handle event"
    e.menu_depth = depth
    e.menu_sel = selection
    GUI_menu_should_handle_event = 128
  end if
end if
END FUNCTION

FUNCTION GUI_button_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_button_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  IF event.m.mrow = e.row1 AND event.m.mcol >= e.col1 AND event.m.mcol <= e.col1 + e.nam.length + 1 THEN
    GUI_button_should_handle_event = e.layer
  END IF
end if
END FUNCTION

FUNCTION GUI_radio_button_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_radio_button_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  if event.m.mrow = e.row1 AND event.m.mcol >= e.col1 AND event.m.mcol <= e.col1 + 2 + e.nam.length THEN
    GUI_radio_button_should_handle_event = e.layer
  end if
end if
END FUNCTION

FUNCTION GUI_label_should_handle_event (e as GUI_element_type, event as GUI_event_mouse_type)
GUI_label_should_handle_event = -130
if event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK or event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  IF event.m.mrow = e.row1 and event.m.mcol >= e.col1 AND event.m.mcol <= e.col1 + e.text.length then
    GUI_label_should_handle_event = e.layer
  end if
end if
END FUNCTION

'###############################################################################
'###############################################################################
'#------------------ELEMENT MOUSE EVENT PROCESS FUNCTIONS----------------------#
'###############################################################################
'###############################################################################

SUB GUI_box_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
END SUB

SUB GUI_input_box_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  IF event.m.mrow = gui(new).row1 + 1 THEN
    IF event.m.mcol > gui(new).col1 + 1 AND event.m.mcol < gui(new).col2 - 1 THEN
      gui(new).text_position = gui(new).scroll_offset_hors + event.m.mcol - gui(new).col1 - 1
      IF gui(new).text_position > gui(new).text.length THEN
        gui(new).text_position = gui(new).text.length
      END IF
    END IF
  END IF
  if NOT GUI_shift_flag then
    gui(new).text_sel_col1 = gui(new).text_position
  end if
  gui(new).text_sel_col2 = gui(new).text_position
  gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
'elseif event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN THEN

'ELSEIF event.flags AND GUI_EVENT_MOUSE_LEFT_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_UP then

elseif event.flags AND GUI_EVENT_MOUSE_DRAG then
  if not GUI_process_mouse_scroll_bar(gui(new), event.m.mrow, event.m.mcol) then
    old_col = gui(new).text_position
    if event.m.mcol <= gui(new).col1 then
      if gui(new).scroll_offset_hors > 0 then
        if TIMER(.001) - GUI_DRAG_TIMER > GUI_DRAG_newECTION_DELAY then
          gui(new).scroll_offset_hors = gui(new).scroll_offset_hors - 1
          gui(new).text_position = gui(new).scroll_offset_hors
          gui(new).text_sel_col2 = gui(new).text_position
          gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
          GUI_DRAG_TIMER = TIMER(.001)
        end if
      end if
    elseif event.m.mcol >= gui(new).col2 then
      if gui(new).scroll_offset_hors - (gui(new).col2 - gui(new).col1) < gui(new).length + 1 then
        if TIMER(.001) - GUI_DRAG_TIMER > .05 then
          gui(new).scroll_offset_hors = gui(new).scroll_offset_hors + 1
          gui(new).text_position = gui(new).scroll_offset_hors + (gui(new).col2 - gui(new).col1 - 1)
          gui(new).text_sel_col2 = gui(new).text_position
          gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
          GUI_DRAG_TIMER = TIMER(.001)
        end if
      end if
    else
      gui(new).text_position = gui(new).scroll_offset_hors + GUI_MCOL - gui(new).col1 - 1
      IF gui(new).text_position > gui(new).text.length THEN
        gui(new).text_position = gui(new).text.length
      END IF
      if old_col <> gui(new).text_position then
        gui(new).text_sel_col2 = gui(new).text_position
        gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED' OR GUI_FLAG_TEXT_IS_newECTED
      end if
    end if
  end if
end if

END SUB

SUB GUI_text_box_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  IF event.m.mrow >= gui(new).row1 + 1 and event.m.mrow <= gui(new).row2 - 1 THEN
    IF event.m.mcol >= gui(new).col1 + 1 AND event.m.mcol <= gui(new).col2 - 1 THEN
      gui(new).selected = event.m.mrow - gui(new).row1 + gui(new).scroll_offset_vert
      gui(new).text_position = gui(new).scroll_offset_hors + event.m.mcol - gui(new).col1 - 1
      if gui(new).selected > gui(new).length then
        gui(new).selected = gui(new).length
      end if
    END IF
  END IF
  GUI_adjust_scroll gui(new), event.m.mrow, event.m.mcol
  gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
elseif event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN THEN
  GUI_hold_scroll_bar gui(new), event.m.mrow, event.m.mcol
'ELSEIF event.flags AND GUI_EVENT_MOUSE_LEFT_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_UP then

ELSEIF event.flags AND GUI_EVENT_MOUSE_SCROLL_UP OR event.flags AND GUI_EVENT_MOUSE_SCROLL_DOWN then
  GUI_process_scroll_wheel_scroll_bar gui(new), event
elseif event.flags AND GUI_EVENT_MOUSE_DRAG then
  n = GUI_process_mouse_scroll_bar(gui(new), event.m.mrow, event.m.mcol)
end if

end sub

sub GUI_list_box_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  IF event.m.mrow >= gui(new).row1 + 1 and event.m.mrow <= gui(new).row2 - 1 THEN
    IF event.m.mcol >= gui(new).col1 + 1 AND event.m.mcol <= gui(new).col2 - 1 then
      s = event.m.mrow - gui(new).row1 + gui(new).scroll_offset_vert
      if gui(new).selected <> s then
        gui(new).selected = s
      end if
    END IF
  END IF
  if gui(new).selected > gui(new).length then gui(new).selected = gui(new).length
  GUI_adjust_scroll gui(new), event.m.mrow, event.m.mcol
  gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
elseif event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN THEN
  GUI_hold_scroll_bar gui(new), event.m.mrow, event.m.mcol
'ELSEIF event.flags AND GUI_EVENT_MOUSE_LEFT_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_UP then

ELSEIF event.flags AND GUI_EVENT_MOUSE_SCROLL_UP OR event.flags AND GUI_EVENT_MOUSE_SCROLL_DOWN then
  GUI_process_scroll_wheel_scroll_bar gui(new), event
elseif event.flags AND GUI_EVENT_MOUSE_DRAG then
  n = GUI_process_mouse_scroll_bar(gui(new), event.m.mrow, event.m.mcol)
end if
end sub

sub GUI_drop_down_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  if old = new and event.m.mrow = gui(new).row1 then
    gui(new).flags = gui(new).flags XOR GUI_FLAG_DROP_FLAG
  end if
  if gui(new).flags AND GUI_FLAG_DROP_FLAG then
    IF event.m.mrow >= gui(new).row1 + 1 and event.m.mrow <= gui(new).row2 - 1 THEN
      IF event.m.mcol >= gui(new).col1 + 1 AND event.m.mcol <= gui(new).col2 - 1 THEN
        s = event.m.mrow - gui(new).row1 + gui(new).scroll_offset_vert
        if s = gui(new).selected then
          gui(new).flags = (gui(new).flags AND NOT GUI_FLAG_DROP_FLAG)
        else
          gui(new).selected = s
        end if
      END IF
    END IF
    GUI_adjust_scroll gui(new), event.m.mrow, event.m.mcol
  end if
  gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
elseif event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN THEN
  if gui(new).flags AND GUI_FLAG_DROP_FLAG then
    GUI_hold_scroll_bar gui(new), event.m.mrow, event.m.mcol
  end if
'ELSEIF event.flags AND GUI_EVENT_MOUSE_LEFT_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_UP then

ELSEIF event.flags AND GUI_EVENT_MOUSE_SCROLL_UP OR event.flags AND GUI_EVENT_MOUSE_SCROLL_DOWN then
  if gui(new).flags AND GUI_FLAG_DROP_FLAG then
    GUI_process_scroll_wheel_scroll_bar gui(new), event
  end if
elseif event.flags AND GUI_EVENT_MOUSE_DRAG then
  if gui(new).flags AND GUI_FLAG_DROP_FLAG then
    n = GUI_process_mouse_scroll_bar(gui(new), event.m.mrow, event.m.mcol)
  end if
end if
end sub

sub GUI_checkbox_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  if event.m.mcol = gui(new).col1 + 1 then gui(new).flags = gui(new).flags XOR GUI_FLAG_CHECKED
  gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
'elseif event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN THEN

'ELSEIF event.flags AND GUI_EVENT_MOUSE_LEFT_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_UP then

'elseif event.flags AND GUI_EVENT_MOUSE_DRAG then

end if
end sub

SUB GUI_menu_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
DIM men as GUI_menu_item_type, mtmp as GUI_menu_item_type, mnext as GUI_menu_item_type
DIM memtmp AS _MEM, offset as _OFFSET

IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  GUI_debug_output "Debth: " + str$(gui(new).menu_depth)
  GUI_debug_output "Selection: " + str$(gui(new).menu_sel)
  if old <> new then gui(new).selected = 0: gui(new).flags = gui(new).flags AND NOT GUI_FLAG_MENU_OPEN
  gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
  if gui(new).menu_depth = 0 then
    if gui(new).menu_sel > 0 then
      GUI_debug_output "Got here as well!"
      gui(new).flags = gui(new).flags OR GUI_FLAG_MENU_OPEN
      gui(new).selected = gui(new).menu_sel
      men = _MEMGET(gui(new).menu, gui(new).menu.OFFSET + len(men) * (gui(new).selected - 1), GUI_menu_item_type)
      if men.has_sub then
        men.sub_menu_open = -1
        GUI_close_sub_menu men
      end if
      men.selected = 1
      _MEMPUT gui(new).menu, gui(new).menu.OFFSET + len(men) * (gui(new).selected - 1), men
    else
      gui(new).selected = 0
      gui(new).flags = gui(new).flags AND NOT GUI_FLAG_MENU_OPEN
    end if
  else
    memtmp = gui(new).menu
    offset = len(mtmp) * (gui(new).selected - 1)
    mtmp = _MEMGET(gui(new).menu, gui(new).menu.OFFSET + len(mtmp) * (gui(new).selected - 1), GUI_menu_item_type)
    FOR d = 1 to gui(new).menu_depth - 1
      men = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(men) * (mtmp.selected - 1), GUI_menu_item_type)
      if d < gui(new).menu_depth then
        memtmp = mtmp.sub_menu
        offset = len(mtmp) * (mtmp.selected - 1)
        mtmp = men
      end if
    NEXT d
    mtmp.selected = gui(new).menu_sel
    _MEMPUT memtmp, memtmp.OFFSET + offset, mtmp
    men = _MEMGET(mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(men) * (mtmp.selected - 1), GUI_menu_item_type)
    
    if men.has_Sub then
      men.sub_menu_open = -1
      men.selected = 1
      GUI_close_sub_menu men
      _MEMPUT mtmp.sub_menu, mtmp.sub_menu.OFFSET + len(men) * (mtmp.selected - 1), men
    else
      gui(new).menu_choice = men.ident
      gui(new).selected = 0
      gui(new).flags = (gui(new).flags OR GUI_FLAG_MENU_CHOSEN OR GUI_FLAG_UPDATED) AND NOT GUI_FLAG_MENU_OPEN
    end if
  end if
end if
end sub

SUB GUI_button_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
DIM e as GUI_event_generic_type, b as GUI_event_element_button_type

IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  GUI_init_event e
  e.event_type = GUI_EVENT_ELEMENT_BUTTON
  b.m_event = event
  b.flags = GUI_EVENT_ELEMENT_BUTTON_CLICKED OR GUI_EVENT_ELEMENT_BUTTON_PRESSED
  b.gui_element = new
  _MEMPUT e.mem, e.mem.OFFSET, b
  GUI_add_event_to_queue e
  GUI_free_event e
  gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
'elseif event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN THEN

'ELSEIF event.flags AND GUI_EVENT_MOUSE_LEFT_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_UP then

'elseif event.flags AND GUI_EVENT_MOUSE_DRAG then

end if
END SUB

SUB GUI_radio_button_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  if event.m.mcol = gui(new).col1 + 1 then
    gui(new).flags = gui(new).flags OR GUI_FLAG_CHECKED
    FOR x = 1 to gui_num
      if x <> new then
        if gui(x).element_type = GUI_RADIO_BUTTON then
          if gui(x).group = gui(new).group then
            gui(x).flags = gui(x).flags AND NOT GUI_FLAG_CHECKED
          end if
        end if
      end if
    NEXT x
  end if
  gui(new).flags = gui(new).flags OR GUI_FLAG_UPDATED
'elseif event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN THEN

'ELSEIF event.flags AND GUI_EVENT_MOUSE_LEFT_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_UP then

'elseif event.flags AND GUI_EVENT_MOUSE_DRAG then

end if
END SUB

SUB GUI_label_process_mouse_event (gui() as GUI_element_type, gui_num, old, new, event as GUI_event_mouse_type)
DIM e as GUI_event_generic_type, l as GUI_event_element_label_type
IF event.flags AND GUI_EVENT_MOUSE_LEFT_CLICK OR event.flags AND GUI_EVENT_MOUSE_RIGHT_CLICK then
  GUI_init_event e
  e.event_type = GUI_EVENT_ELEMENT_LABEL
  l.m_event = event
  l.flags = GUI_EVENT_ELEMENT_LABEL_CLICKED OR GUI_EVENT_ELEMENT_LABEL_PRESSED
  l.gui_element = new
  _MEMPUT e.mem, e.mem.OFFSET, l
  GUI_add_event_to_queue e
  GUI_free_event e
'elseif event.flags AND GUI_EVENT_MOUSE_LEFT_DOWN OR event.flags AND GUI_EVENT_MOUSE_RIGHT_DOWN THEN

'ELSEIF event.flags AND GUI_EVENT_MOUSE_LEFT_UP OR event.flags AND GUI_EVENT_MOUSE_LEFT_UP then

'elseif event.flags AND GUI_EVENT_MOUSE_DRAG then

end if
END SUB

'###############################################################################
'###############################################################################
'#-----------------ELEMENT CLICK RELEASE PROCESS FUNCTIONS---------------------#
'###############################################################################
'###############################################################################

SUB GUI_box_process_focus_release (gui() as GUI_element_type, gui_num, sel)

END SUB

SUB GUI_input_box_process_focus_release (gui() as GUI_element_type, gui_num, sel)

END SUB

SUB GUI_text_box_process_focus_release (gui() as GUI_element_type, gui_num, sel)
gui(sel).flags = (gui(sel).flags AND NOT GUI_FLAG_SCROLL_IS_HELD_H) AND NOT GUI_FLAG_SCROLL_IS_HELD_V
END SUB

SUB GUI_list_box_process_focus_release (gui() as GUI_element_type, gui_num, sel)
gui(sel).flags = (gui(sel).flags AND NOT GUI_FLAG_SCROLL_IS_HELD_H) AND NOT GUI_FLAG_SCROLL_IS_HELD_V
END SUB

SUB GUI_drop_down_process_focus_release (gui() as GUI_element_type, gui_num, sel)
gui(sel).flags = (gui(sel).flags AND NOT GUI_FLAG_DROP_FLAG)
END SUB

SUB GUI_checkbox_process_focus_release (gui() as GUI_element_type, gui_num, sel)

END SUB

SUB GUI_menu_process_focus_release (gui() as GUI_element_type, gui_num, sel)

END SUB

SUB GUI_button_process_focus_release (gui() as GUI_element_type, gui_num, sel)

END SUB

SUB GUI_radio_button_process_focus_release (gui() as GUI_element_type, gui_num, sel)

END SUB

SUB GUI_label_process_focus_release (gui() as GUI_element_type, gui_num, sel)

END SUB

'###############################################################################
'###############################################################################
'#-----------------------ELEMENT GET LAYER FUNCTIONS---------------------------#
'###############################################################################
'###############################################################################

FUNCTION GUI_box_get_layer (b as GUI_element_type)
GUI_box_get_layer = b.layer
END FUNCTION

FUNCTION GUI_input_box_get_layer (b as GUI_element_type)
GUI_input_box_get_layer = b.layer
END FUNCTION

FUNCTION GUI_text_box_get_layer (b as GUI_element_type)
GUI_text_box_get_layer = b.layer
END FUNCTION

FUNCTION GUI_list_box_get_layer (b as GUI_element_type)
GUI_list_box_get_layer = b.layer
END FUNCTION

FUNCTION GUI_drop_down_get_layer (b as GUI_element_type)
if (b.flags AND GUI_FLAG_DROP_FLAG) then
  GUI_drop_down_get_layer = 128
else
  GUI_drop_down_get_layer = b.layer 
end if
END FUNCTION

FUNCTION GUI_checkbox_get_layer (b as GUI_element_type)
GUI_checkbox_get_layer = b.layer
END FUNCTION

FUNCTION GUI_menu_get_layer (b as GUI_element_type)
if b.flags AND GUI_FLAG_MENU_OPEN then
  GUI_menu_get_layer = 128
else 
  GUI_menu_get_layer = b.layer
end if
END FUNCTION

FUNCTION GUI_button_get_layer (b as GUI_element_type)
GUI_button_get_layer = b.layer
END FUNCTION

FUNCTION GUI_radio_button_get_layer (b as GUI_element_type)
GUI_radio_button_get_layer = b.layer
END FUNCTION

FUNCTION GUI_label_get_layer (b as GUI_element_type)
GUI_label_get_layer = b.layer
END FUNCTION

'###############################################################################
'###############################################################################
'#-----------------------ELEMENT KEY EVENT FUNCTIONS---------------------------#
'###############################################################################
'###############################################################################

SUB GUI_box_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)

END SUB

SUB GUI_input_box_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)
if event.flags AND GUI_EVENT_KEY_PRESSED then
  SELECT CASE event.key_code
    CASE ASC(" ") to ASC("~")
      GUI_add_character gui(sel), chr$(event.key_code)
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_BACKSPACE
      GUI_del_character gui(sel)
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_LEFT 
      GUI_move_cursor_left gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_RIGHT
      GUI_move_cursor_right gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
  END SELECT
end if
END SUB

SUB GUI_text_box_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)
if event.flags AND GUI_EVENT_KEY_PRESSED then
  SELECT CASE event.key_code
    CASE ASC(" ") TO ASC("~")
      GUI_add_character_text_box gui(sel), chr$(event.key_code)
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_BACKSPACE
      GUI_del_character_text_box gui(sel)
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_ENTER
      GUI_text_box_handle_enter_key gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_LEFT
      GUI_move_cursor_left gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_RIGHT
      GUI_move_cursor_right gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_UP
      GUI_move_cursor_up gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_DOWN
      GUI_move_cursor_down gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_PGDN
      GUI_move_cursor_page_down gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
    CASE GUI_KEY_CODE_PGUP
      GUI_move_cursor_page_up gui(sel), event
      gui(sel).flags = gui(sel).flags OR GUI_FLAG_UPDATED
      event.key_code = 0
  END SELECT
end if
END SUB

SUB GUI_list_box_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)

END SUB

SUB GUI_drop_down_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)

END SUB

SUB GUI_checkbox_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)

END SUB

SUB GUI_menu_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)

END SUB

SUB GUI_button_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)

END SUB

SUB GUI_radio_button_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)

END SUB

SUB GUI_label_process_key_event (gui() as GUI_element_type, gui_num, sel, event as GUI_event_key_type)

END SUB

'###############################################################################
'###############################################################################
'#-----------------------ELEMENT INITALIZE FUNCTIONS---------------------------#
'###############################################################################
'###############################################################################


